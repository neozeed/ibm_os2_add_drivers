          16:18:15















          

          IBM OS/2 2.0
          Independent Hardware Vendors
          DASD\SCSI Device Support
          
          Revision 0.3
          



          02-18-1992


          Issued by:  Barbara M. Odle, (407) 443-7485
          Technical contact:  Kip Harris, (407) 982-6549

          IBM Corporation
          IBM Internal Zip 1434
          Boca Raton, FL  33429
          
          
          
          
          This document contains advance information, and is subject to change.
          
          

          IBM Unclassified





          
          ABSTRACT

          In order to expedite the development of DASD device support for the
          IBM OS/2 2.0 product, a simplified DASD device programming
          interface is provided.

          This programming interface, described herein, better
          compartmentalizes the DASD device driver modules into hardware
          dependent and hardware independent components.  The hardware
          independent module can be dynamically linked with the hardware
          specific modules for a given workstation configuration.  The
          OEM/IHV need only develop device support to drive his unique device
          interfaces.

          Note: This document contains advance information, and is subject to
          change.







































          
                                                                 Abstract  ii




          
          PREFACE

          About this Document:

          The heart of this document is the specification of the interface
          between an Adapter Device Driver and a Device Manager.  This is
          located in Appendix A. For reference, the 'C' header file which
          defines the data structures, ordinals, and flags used by that
          interface is provided in Appendix B.

          The following sections provide treatment of a variety of topics of
          interest.  In these sections you will find:

          þ   a general overview of the programming interface

          þ   a general overview of what makes up an Adapter Device Driver
              (ADD)

          þ   how ADD's can be used to "filter" requests between a device
              manager and another ADD

          þ   IPL and installation considerations

          þ   DOS compatibility (logical geometry) considerations

          A glossary of terms is provided in the final appendix.



          Revision History

              Revision 0.1 (11/12/91)  Initial draft.

              Revision 0.2 (11/19/91)  Error handling; IORB interface
              updates.

              Revision 0.3 (11/25/91)  Minor editing updates;  IORB interface
              updates.

















          
                                                                 Preface  iii




          
          CONTENTS


            Abstract ..................................................... ii

            Preface ..................................................... iii

            1.0  Introduction ............................................. 1
            1.1  Adapter Device Driver Set ................................ 2
            1.2  Device Managers / OS2DASD ................................ 3
            1.3  Other Device Managers .................................... 4
            1.4  ADD Toolkit Contents ..................................... 5

            2.0  Adapter Device Driver Overview ........................... 6
            2.1  Selected Topics .......................................... 7
            2.2  Developing an ADD ........................................ 8

            3.0  ADD's which act as Filters ............................... 9
            3.1  Strategies for providing Filtering Functions ............ 10
              3.1.1  Installation and Initialization ..................... 10
              3.1.2  Editing another ADD's Device Table .................. 11
              3.1.3  Alternate Strategy:  Ownership of Unit .............. 12
            3.2  Handling of IORB's when Filtering ....................... 12

            4.0  Install and IPL Time Driver Selection ................... 13
            4.1  ADD's for Boot Devices .................................. 13
            4.2  INT 13h ADD ............................................. 14
              4.2.1  INT 13h ADD at Install Time ......................... 14
              4.2.2  INT 13h ADD at Production Time ...................... 14
            4.3  IHV Responsibility for Transparent Install .............. 15

            5.0  DOS Compatibility / Logical Geometries .................. 16

            Appendix A: Device Manager - ADD Interface ................... 17
            Direct Call Commands ......................................... 18
            IORB General Format .......................................... 19
            IOCC_CONFIGURATION ........................................... 28
            IOCC_UNIT_CONTROL ............................................ 39
            IOCC_GEOMETRY ................................................ 41
            IOCC_EXECUTE_IO .............................................. 44
            IOCC_FORMAT .................................................. 48
            IOCC_UNIT_STATUS ............................................. 53
            IOCC_DEVICE_CONTROL .......................................... 56
            IOCC_ADAPTER_PASSTHRU ........................................ 60
            RegisterDeviceClass .......................................... 64
                Processing ............................................... 64
                Results .................................................. 64
            GetDOSVar .................................................... 65
                Processing ............................................... 65
                Results .................................................. 65
                Remarks .................................................. 65

            Appendix B: 'C' Language Data Structure Definitions .......... 66


          
                                                                 Contents  iv




          
            Appendix C: Summary of Error Handling ........................ 77

            Appendix D: Error Management ................................. 78

            Appendix E: Summary of Error Codes ........................... 79

            Appendix F: Library Routines ................................. 87

            Appendix G: OS/2 1.3 Compatibility ........................... 88

            Appendix H: Glossary ......................................... 90












































          
                                                                  Contents  v




          
          LIST OF ILLUSTRATIONS






















































          
                                                    List of Illustrations  vi




          
          1.0  INTRODUCTION



          This document defines the OS/2 Version 2.0 programming interfaces
          for Independent Hardware Vendor (IHV) DASD and SCSI device support.
          (Within this document, the terms IHV and Original Equipment
          Manufacturer (OEM) are used interchangeably).

          The programming interface described by this document does not
          introduce any new software technology, architecture, or significant
          new kernel services.   Instead, these programming interfaces
          represent a reorganization of existing OS/2 DASD and SCSI device
          drivers.  The primary objectives of this reorganization are:

          þ   expedite the development of new DASD/SCSI device support for
              unique device interfaces, by reducing the amount of code
              required and the complexity of that code

          þ   better enable reuse of existing DASD driver code by non-IBM
              development organizations

          þ   better enable OS/2 Version 2.0 for IPL, installation, and
              production operation, on a broad range of (Intel 80386SX (tm)
              compatible) OEM workstations

          In absence of the programming interfaces introduced in this
          document, an OS/2 Version 2.0 device driver for the system DASD is
          a large code module (at least for a device driver), which:

          þ   is usually written in assembly language
          þ   can be more than 15,000 lines of assembler code
          þ   is targeted toward only one of several possible specific bus
              interfaces (e.g., one of ST-506, ABIOS, or SCSI)
          þ   must support a variety of relatively complex OS/2 kernel
              interfaces
          þ   must provide a number of DASD management services that have
              little to do with specifics of driving a particular DASD
              interface

          All of these issues are addressed with the introduction of the OEM
          DASD/SCSI programming interfaces.  The existing system DASD driver
          support is made more granular, so that hardware dependent and
          hardware independent code is compartmentalized.  The hardware
          dependent components are easily replaceable, so that new or
          OEM-unique hardware interfaces to DASD can be provided by non-IBM
          development organizations.

          This diagram illustrates the new code organization:






          
                                                         1.0  Introduction  1




          
           .----------------------------------------------------------.
           |      Hardware Independent System DASD Functions          |
           |           - strategy 1 interfaces                        |
           |           - strategy 2 interfaces                        |
           |           - partition management                         |
           |           - VDD interfaces                               |
           |           - disk mirroring                               |
           |           - other kernel interfaces                      |
           '----------------------------------------------------------'
                    A                   A                  A
                    |                   |                  |
                    V                   V                  V
           .-----------------. .-----------------. .-----------------.
           | HW Dependent    | | HW Dependent    | | HW Dependent    |
           | Diskette Ctrlr  | | Adapter Driver  | | Adapter Driver  |
           |    Driver       | | - e.g.,         | | - e.g.,         |
           |                 | |   OEM disk ctrlr| |   OEM SCSI i/f  |
           '-----------------' '-----------------' '-----------------'
                    A                   A                  A
                    |                   |                  |
                    V                   V                  V
           diskette controller    disk controller      SCSI channel

          A hardware dependent module, which is a member of the lowest layer
          in this device driver hierarchy, is called an 'Adapter Device
          Driver' or 'ADD'.  A hardware independent module which services the
          standard OS/2 request packet interface is called a 'Device
          Manager'.  The ADD <-> Device Manager interface has been designed
          in such a way that the ADD should be little more than a state
          machine, which is responsible for moving blocks of I/O between
          system memory and the target device.



          1.1  ADAPTER DEVICE DRIVER SET

          IBM will support the following device interfaces with ADD's
          packaged with the OS/2 Version 2.0 product:

          þ   NEC 765 compatible diskette controller (ISA and ABIOS
              interfaces)
          þ   ISA ST-506 (includes IDE)
          þ   ABIOS ST-506 and ESDI
          þ   ABIOS SCB

          In order to provide a "safety net" for machines not covered by one
          of the above listed interfaces, a "Generic INT 13" ADD will be
          provided.  This driver establishes a Virtual 86 mode process (not
          visible to the user) and the disk I/O is driven through the CBIOS
          INT 13H DASD interface.  This is a highly standardized interface
          and is expected to enable practically all Intel 386SX (tm)
          compatible workstations for bootstrap and DASD operations.



          
                                                         1.0  Introduction  2




          
          The following summarizes the file names of the ADD's packaged with
          the IBM OS/2 2.0 product, and the device manager that it will
          normally interface with:

              ÚÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
              ³ADD         ³Device Manager ³Supported Devices        ³
              ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
              ³IBMINT13.SYS³  OS2DASD.SYS  ³CBIOS INT13 DASD Devices ³
              ³IBM1S506.SYS³  OS2DASD.SYS  ³ST-506 and IDE Drives    ³
              ³IBM1FLPY.SYS³  OS2DASD.SYS  ³Floppy Drives            ³
              ³IBM2ESDI.SYS³  OS2DASD.SYS  ³ST506/ESDI (ABIOS)       ³
              ³IBM2SCSI.SYS³  OS2DASD.SYS  ³IBM SCSI Adapters (ABIOS)³
              ³IBM2FLPY.SYS³  OS2DASD.SYS  ³IBM Floppy (ABIOS)       ³
              ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ



          1.2  DEVICE MANAGERS / OS2DASD

          A device manager handles a significant portion of the device
          support's administrative duties, and routes actual I/O requests
          down to the ADD that controls the unit associated with the I/O
          request.  The OS2DASD.SYS device manager is supplied by IBM, and is
          intended to act as the device manager for all system DASD.  OS2DASD
          handles these administrative duties and kernel interfaces

          þ   strategy 1 (request packet) kernel interfaces
          þ   strategy 2 (extended device driver) kernel / file system
              interfaces
          þ   command validation
          þ   priority queuing
          þ   disk mirroring
          þ   query functions
          þ   IOCTL parsing
          þ   PDD-VDD interface for DOS session INT 13h services
          þ   scatter/gather emulation
          þ   partition management
          þ   drive letter assignments

          Since OS2DASD conforms to the ADD <-> device manager interface
          described by this document, it will operate with ADD's that control
          any of the following device types:

              ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
              ³ Device Manager³ Supported Devices                    ³
              ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
              ³ OS2DASD.SYS   ³ Removable DASD                       ³
              ³               ³ Non-Removable DASD                   ³
              ³               ³ Write Once/Read Many Optical         ³
              ³               ³ Read/Write Optical                   ³
              ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ




          
                                                         1.0  Introduction  3




          
          1.3  OTHER DEVICE MANAGERS

          A device manager can also serve to translate the ADD <-> device
          manager interface to some other generic SCSI interface that is
          already distributed in the marketplace.  For example, IBM normally
          provides its SCSI feature option support (optical drives and
          optical jukeboxes) through an existing layered model.  The model
          defines a two tier layering as shown here:


           .-----------------.  .--------------------.  .---------------.
           |  CD-ROM Driver  |  | R/W Optical Driver |  |   others ...  |
           '-----------------'  '--------------------'  '---------------'
                     A                     A                   A
                     |                     |                   |
                     V                     V                   V
           .------------------------------------------------------------.
           |                         SCSI.SYS                           |
           '------------------------------------------------------------'
                                           A
                                           |
                                           V
                                     ABIOS Interfaces

          SCSI.SYS defines a generic set of SCSI I/O transport services which
          are then utilized by the device type specific drivers.

          IBM intends to port SCSI.SYS to the ADD <-> device manager model as
          a device manager.  In doing so, existing drivers that interface to
          the SCSI.SYS interface will continue to run in this new
          environment.

          The entire picture of code organization, then, for one possible
          configuration can be abstracted as shown here:





















          
                                                         1.0  Introduction  4




          
           .-------------------------------------. .-----------. .-------.
           | Hardware Independent                | |SCSI option| |       |
           | System DASD Functions               | '-----------' |       |
           |                                     |       A       |SCSI   |
           |                                     |       |       |option |
           |                                     |       V       |       |
           |                                     | .-----------. |       |
           | OS2DASD.SYS                         | |OS2SCSI.SYS| |       |
           '-------------------------------------' '-----------' '-------'
                 A             A              A          A           A
                 |             |              |          |           |
                 V             V              V          V           V
            .---------.  .--------------.  .-----------------------------.
            |Dsk't i/f|  |Adapter Driver|  |        Adapter Driver       |
            '---------'  '--------------'  '-----------------------------'
                 A             A                         A
                 |             |                         |
                 V             V                         V
           dskt ctrl'r   disk controller            SCSI channel

          It is possible for other OEM's to port their existing "generic"
          SCSI interfaces to this new programming interface in the same
          manner.  In doing so, the top half of the ported device manager
          would service the existing "generic" device interface as defined by
          that OEM.  The bottom half of the device manager would conform to
          the ADD <-> device manager interface definition, instead of driving
          a specific device's hardware/BIOS interface.




          1.4  ADD TOOLKIT CONTENTS

          The OS2DASD Device Managers and the IBM supplied ADD's are packaged
          with the IBM OS/2 2.0 base system.

          The tools for writing an ADD will be available either as part of
          the OS/2 Toolkit product, or in an independent toolkit package
          which will be integrated into the OS/2 Toolkit product in a
          subsequent OS/2 Toolkit release.  The "ADD" component of the
          Toolkit will include:

          þ   documentation

          þ   diskette media containing
              -   sample ADD source code
              -   include files (MASM and 'C' language versions)
              -   a library for static linkage with an ADD, which provides a
                  collection of useful services






          
                                                         1.0  Introduction  5




          
          2.0  ADAPTER DEVICE DRIVER OVERVIEW


          An Adapter Device Driver (or "ADD") is in many respects a typical
          OS/2 device driver:

          þ   An ADD uses a 16 bit programming model.

          þ   An ADD has the same load module format as 1.x OS/2 device
              drivers, as do all OS/2 "physical" device drivers.  (Other
              classes of device drivers, which are not in the scope of the
              IHV DASD/SCSI effort, include PM drivers and Virtual device
              drivers).

          þ   An ADD has the same set of DevHlp kernel services as other OS/2
              physical device drivers.

          As mentioned elsewhere, the IHV DASD/SCSI programming interfaces
          described herein are more the result of a reorganization and
          externalization of existing OS/2 DASD device support, than of
          introduction of any significant new software technology.

          Within the context of the existing 16 bit device driver model,
          however, there are a number of additional distinguishing
          characteristics of a device driver that can operate as an ADD:

          þ   An ADD is loaded by a statement in the CONFIG.SYS file.
              However, the usual "DEVICE= ..." statement is replaced by a new
              CONFIG.SYS statement "BASEDEV= ...".  Device drivers loaded by
              a "DEVICE=" statement are called installable drivers, while
              drivers loaded by a "BASEDEV=" statement are called base
              drivers.

          þ   An ADD is initialized at "base device driver" initialization
              time, which is different from the usual initialization context
              of an installable driver.  In particular, the driver is
              initializing in a ring 0 context, and none of the Dos...() API
              set are available.

              By observing the restrictions required for base drivers, an ADD
              and the devices it controls can be used as boot devices.

          þ   As with any OS/2 device driver, the first service request that
              an ADD will receive is an INIT request packet from the kernel.
              As part of the INIT processing, an ADD will issue a call to a
              new DevHlp service to register itself with the kernel.  After
              initialization completes, all subsequent service requests will
              come from a "device manager" rather than from the OS/2 kernel.
              The set of service requests is specified in Appendix A.

              Generally speaking, a design point of the Device Manager <->
              ADD interface has been to minimize the functional content of an
              ADD.  The ADD is intended to be made up of only the algorithms
              which are necessary to drive the state machine of specific DASD

          
                                       2.0  Adapter Device Driver Overview  6




          
              or SCSI interfaces.  The command set in the ADD interface
              reflects this.

          þ   The service request entry point of an ADD, which is analogous
              to the "strategy" entry point of a general purpose OS/2 device
              driver, can be entered in either kernel (aka "task") or
              interrupt contexts.  Consequently, an ADD must NEVER BLOCK
              WHILE SERVICING A REQUEST.

              Service requests which involve time delays are normally
              initiated by the ADD, and then the ADD will immediately return
              to its caller.  Service request completion is indicated to the
              caller by way of asynchronous callback notification.  More on
              this later.

          þ   We recommend that ADD's be written in the 'C' programming
              language.

              Tools and link libraries are provided for writing your ADD in
              'C'. C-language linkages to all DevHlps are also provided.

              Generally, when the 'C' environment is used for an ADD, the
              Small programming model is used (Near code / Near data).  The
              FAR keyword must occasionally be utilized to access data
              buffers that are passed in across the ADD interface.




          2.1  SELECTED TOPICS

          A subsequent revision of this document will include a number of
          breakout discussions on the points raised above:

          þ   INIT time responsibilities
          þ   key data structures in the interface
              -   IORB data structure
              -   scatter/gather lists
          þ   very quick overview of the command set
          þ   some quick notes on IO processing
              -   ADD can spec how deep it wants to queue
              -   memory will be locked down on entry to the add
              -   ADD not responsible for unlocking it
              -   reordering of the queue not permitted
          þ   callback processing










          
                                       2.0  Adapter Device Driver Overview  7




          
          2.2  DEVELOPING AN ADD

          A subsequent revision of this document will include here an
          overview of the basic components of an ADD:

          þ   internal data structures
          þ   initialization component
          þ   iorb entry point and command router
          þ   important library routines (timers, s/g buffering)
          þ   interrupt and timer handling
          þ   callback and completion processing
          þ   error handling











































          
                                       2.0  Adapter Device Driver Overview  8




          
          3.0  ADD'S WHICH ACT AS FILTERS




          There are a number of scenarios in which it is useful to insert one
          or more filtering algorithms between a Device Manager and the ADD
          which is driving the device interface.  This is accomplished under
          the ADD device driver model by installing one or more additional
          ADD drivers into the call down path, between the device manager and
          the device interfacing ADD.  Such an ADD is called a 'filter',
          'filter ADD', or 'filter driver' in this document.

          An sample scenario, which utilizes a filter ADD to encrypt the data
          maintained on a DASD unit, is depicted below:


                Without Filter ADD               With Filter ADD

            .------------------------.     .------------------------.
            | System DASD Device Mgr |     | System DASD Device Mgr |
            |      (eg, os2dasd.sys) |     |      (eg, os2dasd.sys) |
            '------------------------'     '------------------------'
                        A                              A
                        |                              |
                        |                              V
                        |                  .------------------------.
                        |                  | Encryption Algorithm   |
                        |                  |         (a FILTER ADD) |
                        |                  '------------------------'
                        |                              A
                        |                              |
                        V                              V
            .------------------------.     .------------------------.
            | ST-506 i/f Driver      |     | ST-506 i/f Driver      |
            |     (eg, ibm1s506.sys) |     |     (eg, ibm1s506.sys) |
            '------------------------'     '------------------------'

          Filter algorithms are packaged as ADD model device drivers and, in
          general, provide the same service set as any other ADD.  Once
          initialized, filter ADD's receive IORB's from upstream drivers (eg
          device managers), perform the filtering function on the data in the
          IORB, then call down to the ADD(s) that the filter is controlling
          by passing on an IORB.

          One or more filter ADD's can be inserted into the call down path
          for a selected device.

          One or more call down paths can share the same filter.  For
          example, multiple call down paths can share the same filter which
          provides an encryption function.

          This remainder of this section provides the nuts and bolts
          information on how filtering ADD's can be constructed, and

          
                                           3.0  ADD's which act as Filters  9




          
          subsequently inserted, into the device support for a given I/O
          system.



          3.1  STRATEGIES FOR PROVIDING FILTERING FUNCTIONS

          There are two strategies available for inserting a filter ADD into
          the call down path for a given unit's device support:

          1.  Edit the target unit's UNITINFO table, but do not permanently
              ALLOCATE ownership of the unit.
          2.  ALLOCATE the target unit, and present a new UNITINFO table to
              any upstream driver that might issue I/O requests.

          The first strategy, in which the caller does not permanently
          allocate the unit, is a little simpler in most cases.  The filter
          ADD simply daisy chains a filter indicator into the UNITINFO
          structure of the target unit; and I/O which would otherwise go
          directly to the target unit's ADD is then redirected through the
          filter.

          The latter strategy is required when the filter needs to hide
          units.  For example, a data stripping feature can be implemented
          with a filter ADD.  To provide this, the stripping ADD would have
          to allocate all target units, in order to hide them from upstream
          device managers.  The stripping filter would then construct a new
          UNITINFO table that would contain the appropriate information for
          presenting a logical view of a single, logical (stripped) drive.



          3.1.1  INSTALLATION AND INITIALIZATION

          Filter ADD drivers are installed in the same fashion as ADD
          drivers, using BASEDEV= statements in the CONFIG.SYS file of the
          workstation.

          In CONFIG.SYS, the filter ADD is loaded after any ADD's which it
          will control, but before any device manager drivers which the
          filter ADD will serve.  Stated another way, drivers should be
          ordered in CONFIG.SYS in the reverse order of the execution time
          call down path.

          When the filter driver receives its initialization packet from the
          kernel, it will need to scan the workstation's configuration to
          determine which units it will want to control.  This is identical
          to the task that a device manager must perform when it initializes.

          The filter will use the 'GetDOSVar' DevHelp service to obtain a
          list of the entry points for all installed ADD's, and then call
          each ADD to obtain it's device table.  The filter must provide
          storage to contain these device tables.  Once obtaining all the
          device tables, each is scanned for units of interest.

          
                                          3.0  ADD's which act as Filters  10




          
          Having located the units of interest, the filter will need to take
          one of two actions, depending on whether or not the filter is
          implementing a permanent allocation strategy.



          3.1.2  EDITING ANOTHER ADD'S DEVICE TABLE

          If the filter does not need to hide the downstream unit(s), the
          filter can initiate filtering operations by these steps.

          1.  Change the FilterADDHandle field in the target unit's UNITINFO
              structure, so that FilterADDHandle selects the filter ADD.

              When no filters are installed, the FilterADDHandle is
              guaranteed to be zero.  So when a device manager (or other
              upstream ADD driver) finds a zero value in this field, it
              indicates that the referenced ADD is directly managing the
              device interface.

          2.  Change the UnitHandle field in the target unit's UNITINFO
              structure to a value assigned by the filter ADD.

          Note that the filter is daisy-chaining itself into the calldown
          path for a given unit.  So the filter must save the existing
          FilterADDHandle (if non-zero) and UnitHandle values for the
          downstream driver.  After the filter performs its processing on a
          service request, it must pass the request on to the downstream
          filter or device interface ADD.

          The following protocol must be respected when editing a UNITINFO
          structure of another ADD:

          þ   The Filter ADD alters the information provided in the target
              UNITINFO structure by using the (IOCC_UNIT_CONTROL)
              IOCM_CHANGE_UNITINFO command.

          þ   In order to issue IOCM_CHANGE_UNITINFO, the Filter ADD must
              first ALLOCATE the unit, change the UNITINFO information. and
              then DEALLOCATE the unit.

          þ   Changing the UNITINFO information does not affect the operation
              of the downstream ADD. For example, if a filter changes the
              UF_HW_SCATGAT bit, this does not affect the downstream ADD's
              treatment of the unit. However, the downstream ADD should
              present the changed UNITINFO structure when its DEVICETABLE is
              requested.

          þ   It is the responsibility of the filter ADD to convert between
              the changed unit definition it sets and the actual unit
              definition of the ADD owning the unit.

          þ   A filter ADD may modify a unit's flags without actually
              'hooking' the unit. For example a FILTER could set UF_A_DRIVE

          
                                          3.0  ADD's which act as Filters  11




          
              without actually receiving requests. It would do this by
              leaving the original UnitHandle and FilterADDHandle fields
              intact.




          3.1.3  ALTERNATE STRATEGY:  OWNERSHIP OF UNIT

          The alternate strategy is to allocate permanent ownership of the
          target unit from the downstream driver, and present a new device
          table (containing the new representation of the unit) to any
          upstream drivers.  Since the filter ADD retains ownership of the
          downstream resource, it isn't necessary to apply any edits to the
          downstream driver's UNITINFO structures.



          3.2  HANDLING OF IORB'S WHEN FILTERING

          Once installed, a filter ADD may apply these functions to the
          IORB's that it is filtering.

          þ   Generally, the filter ADD should retain the original IORB and
              create new IORB's to pass on to the downstream driver.

          þ   A filter ADD may, however, modify an IORB it receives and pass
              on the same copy of the IORB data structure (versus passing on
              a local copy of the IORB).  If the ADD does this, it must alter
              the notification address, and restore any input fields it had
              modified, prior to doing callout notifications back to the
              upstream driver.

          þ   The filter ADD should not assume the contents of the
              pIORB->ADDWorkSpace will be preserved by a downstream driver.




















          
                                          3.0  ADD's which act as Filters  12




          
          4.0  INSTALL AND IPL TIME DRIVER SELECTION


          Key design points of the IHV DASD/SCSI device support package
          include:

          þ   the ability to install onto (and subsequently boot from) a DASD
              device which requires an IHV specific ADD interface
          þ   an installation process which is transparent to the end-user
              (ie, requires no interaction on the part of the end-user)

          This section describes the strategy which has been developed to
          address these design points, and also describes the
          responsibilities that an ADD supplier has in order to participate
          in this strategy.



          4.1  ADD'S FOR BOOT DEVICES

          When a workstation requires an IHV-specific ADD to operate the boot
          device, there is a "chicken-and-egg" problem.  The OS/2 Install
          process is an OS/2 application that runs on top of a diskette based
          OS/2.  Without the IHV-specific ADD, the OS/2 Install process
          cannot find the target drive on which to initiate its install
          processing.  Without being able to perform I/O to the target
          (future boot) drive, OS/2 Install can't execute to the point where
          it can format the drive for the desired file system and lay out a
          CONFIG.SYS to bring up the required ADD.

          One solution might be to include the ADD's for all possible IHV
          configurations on the OS/2 Install diskette.  However, there are at
          least two drawbacks here:

          þ   This does not accommodate IHV's whose ADD drivers are not
              available at the time that the OS/2 product diskettes are
              manufactured (or IHV's whose drivers are not available for
              shipment with the OS/2 shrink wrap product).

          þ   The boot DASD ADD must be available on one of the first
              diskettes in the installation package.  It's anticipated that
              there isn't sufficient free space on these diskettes to
              accommodate the number of ADD's required.

          Another alternative would be modification of the install process to
          eliminate the dependency on the target drive.  This is perhaps a
          workable solution, but IBM has chosen an alternate strategy that
          drags along other benefits.  This strategy is based on an "INT 13h"
          ADD.






          
                               4.0  Install and IPL Time Driver Selection  13




          
          4.2  INT 13H ADD

          An ADD called OS2INT13.SYS is included with the standard set of
          ADD's shipped with the OS/2 shrink wrap package.  When activated,
          this ADD establishes a background VDM process which drives disk I/O
          through the INT 13h interface of the OEM's BIOS.  Due to the highly
          standardized nature of the INT 13h BIOS interface, we believe that
          this ADD will successfully operate any unique DASD interfaces on
          practically all of the 80386SX (and above) DOS compatible
          workstations in the marketplace.

          However, since the OEM BIOS definition is used, this ADD can only
          control drives that are identified as BIOS drive numbers 80h or
          81h.  (By convention, drive 80h is the boot device when booting
          from fixed disk).  The assignments of BIOS drive numbering to
          physical drives is made during POST processing, and numbering is
          assigned in the order that the adapters are found in adapter
          memory.



          4.2.1  INT 13H ADD AT INSTALL TIME

          When the OS/2 Install program is run on ISA bus compatible
          machines, it will load ADD's for both the ST-506 and INT 13h
          interfaces.  If the ST-506 support does not recognize BIOS drive
          numbers 80h and/or 81h, the INT 13h driver will provide support for
          the unsupported drive(s).

          It's assumed that an IHV-specific ADD for the unrecognized drive
          will be installed later in the installation process.  When an ADD
          is installed which recognizes the 80h or 81h drive, the INT 13h ADD
          will no longer attempt to operate that drive.

          In summary, the INT 13 ADD is intended primarily as a mechanism for
          getting through the install process.



          4.2.2  INT 13H ADD AT PRODUCTION TIME

          In absence of an ADD which recognizes the IHV-specific drive
          interface, the INT 13 ADD will continue to drive the DASD at
          production time.  We believe the performance of the INT 13 driver
          will be generally acceptable so long as multi-threaded DASD I/O
          operation to that drive is not required.









          
                               4.0  Install and IPL Time Driver Selection  14




          
          4.3  IHV RESPONSIBILITY FOR TRANSPARENT INSTALL

          *Preliminary*

          Since the INT 13h ADD gets us through the Install process, the
          installation of ADD's for boot devices and non-boot devices is
          handled identically.  IHV-specific ADD's are installed near the end
          of the Install process, when other feature options (such as Mouse
          support or Printer support) are supplied.

          All IHV-specific ADD's will be installed using the DDINSTAL
          utility.  This utility reads a file containing a script, called a
          'Device Driver Profile', for determining which files to copy from a
          diskette, where to put them, and how to update the CONFIG.SYS file
          installation.

          OS/2 1.x versions of this utility required that an end user
          explicitly select those drivers that he wished to install, from a
          menu of Device Driver Profile "scripts".  We believe that asking
          the end-user to identify the DASD interface support in his
          workstation (as is done today with Mouse or Printer support) is an
          undesirable usability concern.

          Consequently, the DDINSTAL language processor has been extended
          with a new keyword, PREDICATE.  The PREDICATE keyword identifies
          the name of an executable program which will return a TRUE or
          FALSE.  If the predicate function returns TRUE, the corresponding
          installation script is processed and the driver is installed.

          The IHV who creates an ADD is responsible for providing Device
          Driver Profiles and associated predicate functions (which determine
          whether any of device interfaces manufactured by his company are
          installed in the workstation).  The following information will be
          made available to this function:

          þ   POS information on ABIOS machines

          þ   read-only access to the physical memory in locations C0000h to
              FFFF0h will be available on all machine configurations

          þ   (*preliminary*) access to I/O ports which are not claimed by
              standard system hardware subsystems.

          Specific programming interfaces on in this area are TBD.











          
                               4.0  Install and IPL Time Driver Selection  15




          
          5.0  DOS COMPATIBILITY / LOGICAL GEOMETRIES

          *Preliminary*

          This section addresses the issue of logical cylinders / head /
          sector (CHS) geometries that may be presented by a particular OEM's
          BIOS.

          The physical geometries of many current hardfiles exceed the range
          of cylinder, head, or sector values that BIOS defines in the INT
          13h interface.  This incompatibility (between the physical drive
          characteristics and the maximum acceptable BIOS CHS values) is
          often resolved by translating an incompatible physical geometry
          into a compatible, logical geometry.

          For example, INT 13h BIOS defines a maximum of 1024 cylinders and
          64 heads.  Some currently marketed drives have more than 1024
          cylinders but fewer than 32 heads.  By mapping the physical
          geometry to twice the heads and half the cylinders, the total
          capacity of the drive may be accessed within the BIOS interfacing
          constraints.

          There is potential for trouble here when different physical to
          logical mapping are used by DOS versus OS/2 device support.  When
          this physical/logical translation is integrated into the drive's
          controller, there is no problem;  both real and protect mode device
          support will see the same geometry.

          However, this mapping is sometimes provided in the OEM BIOS.  When
          this is the case, an compatibility problem is created if an ADD
          implements a different physical/logical CHS mapping than the
          mapping that is defined by the OEM BIOS.  The problem will surface
          when the drive is formatted under one of the two operating systems,
          and then subsequently accessed by the other.

          Specifications on the solution for this is TBD.  Preliminary
          information is provided as follows:

          An ADD is responsible for automatically determining when this
          problem exists, for determining the BIOS mapping between physical
          and logical when it exists, and for emulating the BIOS mapping.

          An override mechanism will also be provided.  CONFIG.SYS command
          line parameters will be made available to an ADD.  A syntax for
          explicit definition of CHS mappings will be provided in a
          subsequent revision of this document.  For example, the syntax may
          look like this:

          BASEDEV=xyzSCSI.SYS /unit:1 /chs:1024,64,32

          All DASD ADD's will be responsible for checking for the presence of
          the command line string, and implementing the logical translation
          when the CHS override is specified.


          
                              5.0  DOS Compatibility / Logical Geometries  16




          
          APPENDIX A: DEVICE MANAGER - ADD INTERFACE


          The IBM OS/2 2.0 DASD\SCSI Device Manager Interface consists of the
          following direct call commands and DevHlps services:

          þ   Direct Call Commands
              -   CONFIGURATION
                  --  GET_DEVICE_TABLE
              -   UNIT_CONTROL
                  --  ALLOCATE_UNIT
                  --  DEALOCATE_UNIT
                  --  CHANGE_UNITINFO
              -   GEOMETRY
                  --  GET_MEDIA_GEOMETRY
                  --  SET_MEDIA_GEOMETRY
                  --  GET_DEVICE_GEOMETRY
                  --  SET_MEDIA_GEOMETRY
                  --  SET_LOGICAL_GEOMETRY
              -   EXECUTE_IO
                  --  READ
                  --  READ_VERIFY
                  --  READ_PREFETCH
                  --  WRITE
                  --  WRITE_VERIFY
              -   FORMAT
                  --  FORMAT_MEDIA
                  --  FORMAT_TRACK
                  --  FORMAT_PROGRESS
              -   UNIT_STATUS
                  --  GET_UNIT_STATUS
                  --  CHANGELINE_STATE
                  --  GET_MEDIA_SENSE
              -   DEVICE_CONTROL
                  --  ABORT
                  --  RESET
                  --  SUSPEND
                  --  RESUME
                  --  LOCK_MEDIA
                  --  UNLOCK_MEDIA
                  --  EJECT_MEDIA
              -   ADAPTER_PASSTHRU
                  --  EXECUTE_SCB
                  --  EXECUTE_CDB

          þ   DevHlp Services
              -   RegisterDeviceClass
              -   GetDOSVar







          
                               Appendix A: Device Manager - ADD Interface  17




          



          DIRECT CALL COMMANDS

          All direct call commands are issued by the device managers
          (OS2DASD.SYS and OS2SCSI.SYS) or filter ADDs, to an ADD's
          registered entry point, with a global pointer to the Input/Output
          Request Block (IORB).

          C Language Syntax

          #include <iorb.h>

          VOID (FAR * ADD Entry Point) (piorb);

          PIORB   piorb         /* far pointer to the IORB */

          Assembly Language Syntax

          #include <iorb.inc>

          piorb   DD      ?        ; far pointer to the IORB


          PUSH    piorb         ; push the parameter
          CALL    [FAR * ADD Entry Point]


          Parameters
              ÚÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
              ³piorb ³ Far Ptr to the IORB Control Block   ³
              ÀÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

          Results

          The results of the command is returned in the IORB.

          IORB Control Block

          All direct call command control blocks are defined in the IBM
          supplied IORB.H and IORB.INC include files (See Appendix E, "IORB
          Include Files").  The following sections, which describe the
          commands and their associated control blocks, are written from the
          point of view of both C and ASM programmers, with references to the
          actual include file, field names.









          
                               Appendix A: Device Manager - ADD Interface  18




          
          IORB GENERAL FORMAT

          The Input/Output Request Block (IORB) is the main control block for
          all direct call commands.  To allow for varying command-specific
          data, there are eight types of IORBs, one per CommandCode.  They
          are:

              ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
              ³CommandCode           ³ IORB Type             ³
              ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
              ³IOCC_CONFIGURATION    ³ IORB_GETDEVICETABLE   ³
              ³IOCC_UNIT_CONTROL     ³ IORB_UNIT_CONTROL     ³
              ³IOCC_GEOMETRY         ³ IORB_GEOMETRY         ³
              ³IOCC_EXECUTE_IO       ³ IORB_EXECUTE_IO       ³
              ³IOCC_FORMAT           ³ IORB_FORMAT           ³
              ³IOCC_UNIT_STATUS      ³ IORB_UNIT_STATUS      ³
              ³IOCC_DEVICE_CONTROL   ³ IORB_DEVICE_CONTROL   ³
              ³IOCC_ADAPTER_PASSTHRU ³ IORB_ADAPTER_PASSTHRU ³
              ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

          Each IORB consists of a common IORBH (Input/Output Request Block
          Header), followed by unique command-specific data.

                  ÚÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                  ³ IORBH ³ I/O Request Block Header     ³
                  ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                  ³ ----- ³ Command-Specific Data        ³
                  ÀÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

          þ   IORBH

              ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
              ³Field Name      ³C-Type  ³Length³Description            ³
              ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
              ³Length          ³USHORT  ³DW    ³Length of IORB         ³
              ³UnitHandle      ³USHORT  ³DW    ³Unit Handle            ³
              ³CommandCode     ³USHORT  ³DW    ³Command Code           ³
              ³CommandModifier ³USHORT  ³DW    ³Command Modifier       ³
              ³RequestControl  ³USHORT  ³DW    ³Flags                  ³
              ³Status          ³USHORT  ³DW    ³Status                 ³
              ³ErrorCode       ³USHORT  ³DW    ³Error Code             ³
              ³Timeout         ³ULONG   ³DD    ³Completion Timeout     ³
              ³StatusBlockLen  ³USHORT  ³DW    ³Length of Status Info  ³
              ³pStatusBlock    ³NPBYTE  ³DW    ³Ptr to Status Info     ³
              ³Reserved_1      ³ULONG   ³DW    ³Reserved               ³
              ³pNxtIORB        ³PIORB   ³DD    ³Ptr to next IORB       ³
              ³NotifyAddress   ³(*PFN)()³DD    ³Notification Address   ³
              ³AssocUnitCB     ³NPBYTE  ³DW    ³Reserved               ³
              ³Reserved_2      ³ULONG   ³DD    ³Reserved               ³
              ³AssocRequest    ³PBYTE   ³DD    ³Reserved               ³
              ³DMWorkSpace[10] ³UCHAR   ³DB(10)³Reserved               ³
              ³ADDWorkSpace[16]³UCHAR   ³DB(16)³ADD Work Area          ³
              ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


          
                               Appendix A: Device Manager - ADD Interface  19




          
              On entry to the ADD:






















































          
                               Appendix A: Device Manager - ADD Interface  20




          
               Length is set to the total length in bytes of the IORB (IORBH
                   plus Command-Specific Data).

               UnitHandle identifies the ADD's unit, for which the request is
                   intended.  The ADD assigns a unique UnitHandle, in the
                   DEVICETABLE - UNITINFO structure, for each of the units it
                   manages.  Refer to the IOCC_CONFIGURATION CommandCode
                   section, for additional information.

               CommandCode/CommandModifier contains the direct call command.
                   The commands are grouped by CommandCode.  The CommandCode
                   field defines the type of IORB and the CommandModifier
                   field defines the command within the specified
                   CommandCode.  For details on each of the commands, refer
                   to their corresponding CommandCode sections.

                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³CommandCode           ³ CommandModifier          ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³IOCC_CONFIGURATION    ³ IOCM_GET_DEVICE_TABLE    ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³IOCC_UNIT_CONTROL     ³ IOCM_ALLOCATE_UNIT       ³
                   ³                      ³ IOCM_DEALLOCATE_UNIT     ³
                   ³                      ³ IOCM_CHANGE_UNITINFO     ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³IOCC_GEOMETRY         ³ IOCM_GET_MEDIA_GEOMETRY  ³
                   ³                      ³ IOCM_SET_MEDIA_GEOMETRY  ³
                   ³                      ³ IOCM_GET_DEVICE_GEOMETRY ³
                   ³                      ³ IOCM_SET_LOGICAL_GEOMETRY³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³IOCC_EXECUTE_IO       ³ IOCM_READ                ³
                   ³                      ³ IOCM_READ_VERIFY         ³
                   ³                      ³ IOCM_READ_PREFETCH       ³
                   ³                      ³ IOCM_WRITE               ³
                   ³                      ³ IOCM_WRITE_VERIFY        ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³IOCC_FORMAT           ³ IOCM_FORMAT_MEDIA        ³
                   ³                      ³ IOCM_FORMAT_TRACK        ³
                   ³                      ³ IOCM_FORMAT_PROGRESS     ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³IOCC_UNIT_STATUS      ³ IOCM_GET_UNIT_STATUS     ³
                   ³                      ³ IOCM_GET_CHANGELINE_STATE³
                   ³                      ³ IOCM_GET_MEDIA_SENSE     ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³IOCC_DEVICE_CONTROL   ³ IOCM_ABORT               ³
                   ³                      ³ IOCM_RESET               ³
                   ³                      ³ IOCM_SUSPEND             ³
                   ³                      ³ IOCM_RESUME              ³
                   ³                      ³ IOCM_LOCK_MEDIA          ³
                   ³                      ³ IOCM_UNLOCK_MEDIA        ³
                   ³                      ³ IOCM_EJECT_MEDIA         ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³IOCC_ADAPTER_PASSTHRU ³ IOCM_EXECUTE_SCB         ³
                   ³                      ³ IOCM_EXECUTE_CDB         ³

          
                               Appendix A: Device Manager - ADD Interface  21




          
                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ






















































          
                               Appendix A: Device Manager - ADD Interface  22




          
               RequestControl contains flags defined only for IOCC_EXECUTEIO,
                   IOCC_FORMAT, and IOCC_ADAPTER_PASSTHRU CommandCodes.  For
                   all other CommandCodes, this field equals zero.

                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³RequestControl Flags ³ Description                ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³IORB_ASYNC_POST      ³ Command Completion Protocol³
                   ³                     ³ If set, this flag indicates³
                   ³                     ³ that the NotifyAddress     ³
                   ³                     ³ field is valid.  Therefore,³
                   ³                     ³ the ADD queues the command ³
                   ³                     ³ for service and returns,   ³
                   ³                     ³ with no immediate return   ³
                   ³                     ³ code.  Once the command    ³
                   ³                     ³ completes, the ADD calls   ³
                   ³                     ³ the notification routine   ³
                   ³                     ³ with it completion STATUS. ³
                   ³                     ³ If not set, this flag      ³
                   ³                     ³ indicates that the ADD     ³
                   ³                     ³ services the request, sets ³
                   ³                     ³ its completion STATUS and  ³
                   ³                     ³ returns.                   ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³IORB_CHAIN           ³ IORB chaining              ³
                   ³                     ³ If set, this flag indicates³
                   ³                     ³ that the PNxtIORB field    ³
                   ³                     ³ is valid and that there is ³
                   ³                     ³ a chained IORB command to  ³
                   ³                     ³ service.                   ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³IORB_CHS_ADDRESSING  ³ I/O Addressing Format      ³
                   ³                     ³ If set, this flag indicates³
                   ³                     ³ that the command's RBA     ³
                   ³                     ³ field is in the format     ³
                   ³                     ³ defined by the CHS_ADDR    ³
                   ³                     ³ structure.                 ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³IORB_REQ_STATUSBLOCK ³ Request For Status Info    ³
                   ³                     ³ If set, this flag indicates³
                   ³                     ³ that the StatusBlockLength ³
                   ³                     ³ and pStatusBlock fields are³
                   ³                     ³ valid and that the ADD     ³
                   ³                     ³ should return the command's³
                   ³                     ³ associated status info.    ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³IORB_DISABLE_RETRY   ³ No Error, Do Not Retry     ³
                   ³                     ³ If set, this flag indicates³
                   ³                     ³ that the ADD should not    ³
                   ³                     ³ retry the request if an    ³
                   ³                     ³ processing error occurs.   ³
                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ



          
                               Appendix A: Device Manager - ADD Interface  23




          
               Status equals zero, on entry.  On exit from the ADD, it
                   contains flags to indicate the commands completion status.

                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³Status Flags          ³Description                ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³IORB_DONE             ³No Errors                  ³
                   ³                      ³If set, this flag indicates³
                   ³                      ³that the ADD has completed ³
                   ³                      ³the request.               ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³IORB_ERROR            ³Error Encountered          ³
                   ³                      ³If set, this flag indicates³
                   ³                      ³that an error has occurred ³
                   ³                      ³while processing the       ³
                   ³                      ³request.  This flag is only³
                   ³                      ³valid if the IORB_DONE flag³
                   ³                      ³is set.                    ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³IORB_RECOV_ERROR      ³Recoverable Error          ³
                   ³                      ³If set, this flag indicates³
                   ³                      ³that although an error     ³
                   ³                      ³occurred, the ADD          ³
                   ³                      ³successfully recovered from³
                   ³                      ³the error through retries. ³
                   ³                      ³This flag is only valid if ³
                   ³                      ³the IORB_DONE and the      ³
                   ³                      ³IORB_ERROR flags are set.  ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³IORB_STATUSBLOCK_AVAIL³Status Info Returned       ³
                   ³                      ³If set, this flag indicates³
                   ³                      ³that the ADD has returned  ³
                   ³                      ³status information in the  ³
                   ³                      ³buffer defined by the      ³
                   ³                      ³pStatusBlock field.  This  ³
                   ³                      ³flag is only valid if the  ³
                   ³                      ³IORB_DONE flag is set.     ³
                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

               ErrorCode equals zero, on entry.  On exit from the ADD, it
                   contains the command's completion error code.  This field
                   is only valid if the IORB_ERROR flag in the Status field
                   is set.  The error codes are summarized in Appendix F,
                   "Summary of Error Codes".

               Timeout contains the maximum number of seconds the ADD should
                   allow for command completion before timing out.  If this
                   field is set to 0, the timeout value assigned is the
                   default, set by the ADD.  If this field is set to -1, the
                   timeout value assigned is infinite.  The timeout period is
                   measured from the last valid contact (interrupt) with the
                   target device.  Therefore, if the device periodically
                   interrupts, within the timeout interval, the interval is
                   reset after each interrupt.

          
                               Appendix A: Device Manager - ADD Interface  24




          





















                                    Intentionally Left Blank

































          
                               Appendix A: Device Manager - ADD Interface  25




          
               StatusBlockLength contains the size, in bytes, of the block of
                   storage for the ADD to return status information
                   (pStatusBlock).  This field is only valid if the
                   RequestControl field, IORB_REQ_STATUSBLOCK flag is set.

               pStatusBlock contains a far pointer to a block of storage
                   (length = StatusBlockLength), allocated by the caller, for
                   the ADD to return status information.  On exit from the
                   ADD, the storage area contains status information, in the
                   ADD's defined format.  This field is only valid if the
                   RequestControl field, IORB_REQ_STATUSBLOCK flag is set.

               Reserved_1 is reserved for use by the device manager and must
                   not be modified by the ADD.

               pNxtIORB contains a far pointer to the next IORB for chained
                   commands.  This field is only valid if the RequestControl
                   field, IORB_CHAIN flag is set.

               NotifyAddress contains a far pointer to the notification
                   routine to be called when the request has completed
                   successfully or aborted due to error conditions.  This
                   field is only valid if the RequestControl field,
                   IORB_ASYNC_POST flag is set.  The notification routine
                   should be called with a far pointer to the command's IORB.

                   C Language Syntax

                   (*piorb->NotifyAddress) (piorb);

                   Assembly Language Syntax

          PUSH    piorb         ; push the parameter
          CALL    [FAR *piorb->NotifyAddress]

                   Note: ADD must preserve registers: DS,ES,SI and DI.

               AssocUnitCB is reserved for use by the device manager and must
                   not be modified by the ADD.

               Reserved_2 is reserved for use by the device manager and must
                   not be modified by the ADD.

               AssocRequest is reserved for use by the device manager and
                   must not be modified by the ADD.

               DMWorkSpace[10] defines a workspace for use by the device
                   manager, which must not be modified by the ADD.

               ADDWorkSpace[16] defines a workspace for the ADD, which is
                   ignored by the device manager.

                          


          
                               Appendix A: Device Manager - ADD Interface  26




          
          þ   Command-Specific Data

              contains the command unique parameters.  The commands and the
              actual formats of the corresponding IORBs are discussed in the
              following sections.


















































          
                               Appendix A: Device Manager - ADD Interface  27




          
          IOCC_CONFIGURATION

          The IOCC_CONFIGURATION CommandCode consists of all the
          CommandModifiers responsible for returning information about the
          characteristics of the devices supported by the ADD.  The
          CommandModifiers are:

          þ   IOCM_GET_DEVICE_TABLE

              Returns the DEVICETABLE structure, in the buffer supplied by
              the caller.  The DEVICETABLE is a complex structure, which
              contains detailed information on each adapter and its
              associated units supported by the ADD.



          Remarks

          þ   Support: Manditory
          þ   Called By: OS2DASD.SYS, OS2SCSI.SYS or filter ADD
          þ   Context of Call: INIT and TASK




          Format of IORB

          þ   IORB Type = IORB_GETDEVICETABLE
          þ   IORBH Fields
              -   RequestControl = All flags are disabled.
              -   CommandCode = IOCC_CONFIGURATION
              -   CommandModifier = IOCM_GET_DEVICE_TABLE




          IORB_GETDEVICETABLE Description

          This section defines the IORB_GETDEVICETABLE control block and its
          associated structures:

          þ   DEVICETABLE - Table of Supported Devices
          þ   ADAPTERINFO - Adapter Characteristics
          þ   UNITINFO    - Unit Characteristics











          
                               Appendix A: Device Manager - ADD Interface  28




          


                            :hp2.DEVICETABLE Overview:ehp2.


          IORB_GETDEVICETABLE

           -------------------.
          |   pDeviceTable    |-> DEVICETABLE
          '-------------------'
                                 .---------------.
                          .------|pAdapter[0]    |
                          |      |---------------|
                          |  .---|pAdapter[1]    |
                          |  |   |---------------|
                          |  |   |    ...        |
                          |  |   |---------------|
                          |  | .-|pAdapter[N]    |
                          |  | | |---------------|  .-----------.
                          |  | | |---------------|  |           |
                          '----->|ADAPTERINFO 0  |--| ADAPTER 0 |-.
                             | | |---------------|  |           | |   .------.
                             | | |  UNITINFO[0]  |  '-----------' |---|UNIT 0|
                             | | |  UNITINFO[1]  |                |   '------'
                             | | |      ...      |                |     ...
                             | | |  UNITINFO[N]  |                |   .------.
                             | | |---------------|                |---|UNIT N|
                             | | |---------------|  .-----------.     '------'
                             | | |---------------|  |           |
                             '-->|ADAPTERINFO 1  |--| ADAPTER 1 |-.
                               | |---------------|  |           | |   .------.
                               | |  UNITINFO[0]  |  '-----------' |---|UNIT 0|
                               | |  UNITINFO[1]  |                |   '------'
                               | |      ...      |                |     ...
                               | |  UNITINFO[N]  |                |   .------.
                               | |---------------|                |---|UNIT N|
                               | |---------------|  .-----------.     '------'
                               | |---------------|  |           |
                               '>|ADAPTERINFO N  |--| ADAPTER N |-.
                                 |---------------|  |           | |   .------.
                                 |  UNITINFO[0]  |  '-----------' |---|UNIT 0|
                                 |  UNITINFO[1]  |                |   '------'
                                 |      ...      |                |     ...
                                 |  UNITINFO[N]  |                |   .------.
                                 '---------------'                |---|UNIT N|
                                                                      '------'









          
                               Appendix A: Device Manager - ADD Interface  29




          
          þ   IORB_GETDEVICETABLE

              ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
              ³Field Name    ³C-Type           ³Length³Description     ³
              ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
              ³iorbh         ³IORBH            ³DB(68)³IORB Header     ³
              ³pDeviceTable  ³FAR *PDEVICETABLE³DD    ³Device Table    ³
              ³DeviceTableLen³ULONG            ³DD    ³Length of Table ³
              ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

              On entry to the ADD:

               iorbh Refer to the "General IORB Format" section.

               pDeviceTable contains a far pointer to a block of storage
                   (length = DeviceTableLen), allocated by the the caller,
                   for the ADD to return the DEVICETABLE.

               DeviceTableLen contains the length, in bytes, of the block of
                   storage, for the ADD to return the DEVICETABLE
                   (pDeviceTable).

          þ   DEVICETABLE

              ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
              ³Field Name   ³C-Type       ³Length³Description           ³
              ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
              ³ADDLevelMajor³UCHAR        ³DB    ³ADD Major Level       ³
              ³ADDLevelMinor³UCHAR        ³DB    ³ADD Minor Level       ³
              ³ADDHandle    ³USHORT       ³DW    ³ADD Index             ³
              ³TotalAdapters³USHORT       ³DW    ³number of Adapters    ³
              ³pAdapter[N]  ³NPADAPTERINFO³DW(N) ³AdapterInfo Ptrs      ³
              ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

              On exit from the ADD:

               ADDLevelMajor/ADDLevelMinor defines the level of support the
                   ADD is written to.  An ADD, written to this specification
                   (IBM 0S/2 2.0 Support Level), should set the fields as
                   follows:

                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³Field Name      ³ Value                ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³ADD_Level_Major ³ ADDLEVELMAJOR2       ³
                   ³ADD_Level_Minor ³ ADDLEVELMINOR0       ³
                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

               ADDHandle contains the ADD's index returned by the
                   RegisterDeviceClass DevHlp.

               TotalAdapters defines the number of adapters the ADD supports.

               pAdapter[N] contains an array of near ADAPTERINFO pointers.

          
                               Appendix A: Device Manager - ADD Interface  30




          
                   The number of elements in the array is determined by the
                   TotalAdapters field.





















































          
                               Appendix A: Device Manager - ADD Interface  31




          
          þ   ADAPTERINFO

              ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
              ³Field Name          ³C-Type  ³Length³Description        ³
              ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
              ³AdapterName[17]     ³UCHAR   ³DB(17)³ASCIIZ Name        ³
              ³Reserved            ³UCHAR   ³DB    ³16 Bit Alignment   ³
              ³AdapterUnits        ³USHORT  ³DW    ³Number of Units    ³
              ³AdapterDevBus       ³USHORT  ³DW    ³Device Bus Type    ³
              ³AdapterIOAccess     ³UCHAR   ³DB    ³Host I/O Type      ³
              ³AdapterHostBus      ³UCHAR   ³DB    ³Host Bus Type      ³
              ³AdapterSCSITargetID ³UCHAR   ³DB    ³Target ID          ³
              ³AdapterSCSILUN      ³UCHAR   ³DB    ³Logical Unit#      ³
              ³AdapterFlags        ³USHORT  ³DW    ³Flags              ³
              ³MaxHWSGList         ³USHORT  ³DW    ³Max S/G Elements   ³
              ³MaxCDBTransferLength³ULONG   ³DD    ³Max CDB length     ³
              ³UnitInfo[N]         ³UNITINFO³DD(N) ³Unit Information   ³
              ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

              On exit from the ADD:

               AdapterName[17] contains the ASCIIZ name string of the
                   adapter.  This name is used by the caller for diagnostic
                   purposes.

               Reserved contains a zero.  This is a 16-bit alignment byte.

               AdapterUnits contains the number of units supported by this
                   adapter.

               AdapterDevBus defines the adapter to device bus protocol used.

                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³AdapterDevBus Protocol³ Description             ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³AI_DEVBUS_ST506       ³ DASD - ST506 CAM-I      ³
                   ³AI_DEVBUS_ST506_II    ³ DASD - ST506 CAM-II     ³
                   ³AI_DEVBUS_ESDI        ³ DASD - ESDI             ³
                   ³AI_DEVBUS_FLOPPY      ³ DASD - Diskette         ³
                   ³AI_DEVBUS_SCSI_1      ³ SCSI_1 Format           ³
                   ³AI_DEVBUS_SCSI_2      ³ SCSI_2 Format           ³
                   ³AI_DEVBUS_SCSI_3      ³ SCSI_3 Format           ³
                   ³AI_DEVBUS_OTHER       ³ Protocol Not Listed     ³
                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³AdapterDevBus Modifiers  ³ Description          ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³AI_DEVBUS_FAST_SCSI      ³ SCSI Devices Only    ³
                   ³AI_DEVBUS_8BIT           ³  8 Bit Bus Width     ³
                   ³AI_DEVBUS_16BIT          ³ 16 Bit Bus Width     ³
                   ³AI_DEVBUS_32BIT          ³ 32 Bit Bus Width     ³
                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


          
                               Appendix A: Device Manager - ADD Interface  32




          
                   Note: One protocol should be selected, OR'd with the
                   appropriate modifiers.





















































          
                               Appendix A: Device Manager - ADD Interface  33




          
               AdapterIOAccess defines the adapter to host I/O data transfer
                   capabilities.

                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³AdapterIOAccess Flags  ³Description             ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³AI_IOACCESS_BUS_MASTER ³1st Party DMA Adapter   ³
                   ³AI_IOACCESS_PIO        ³Programmed INs/OUTs     ³
                   ³AI_IOACCESS_DMA_SLAVE  ³2nd Party DMA Adapter   ³
                   ³AI_IOACCESS_MEMORY_MAP ³Memory Mapped I/O       ³
                   ³AI_IOACCESS_OTHER      ³I/O Access Not Listed   ³
                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

                   Note: Multiple Flags may be set.

               AdapterHostBus defines the adapter to host bus type used.

                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³AdapterHostBus Type   ³ Device Connection           ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³AI_HOSTBUS_ISA        ³ ISA                         ³
                   ³AI_HOSTBUS_EISA       ³ Extended ISA                ³
                   ³AI_HOSTBUS_uCHNL      ³ Micro Channel               ³
                   ³AI_HOSTBUS_OTHER      ³ Bus Type Not Listed         ³
                   ³AI_HOSTBUS_UNKNOWN    ³ Bus Type Unknown            ³
                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³AdapterHostBus Width  ³ Description             ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³AI_HOSTBUS_8BIT       ³  8 Bit Bus              ³
                   ³AI_HOSTBUS_16BIT      ³ 16 Bit Bus              ³
                   ³AI_HOSTBUS_32BIT      ³ 32 Bit Bus              ³
                   ³AI_HOSTBUS_64BIT      ³ 64 Bit Bus              ³
                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

                   Note: One bus type should be set with one width OR'd in.

               AdapterSCSITargetID contains the target ID for the SCSI
                   adapter.  For non-SCSI devices this field should be set to
                   zero.

               AdapterSCSIPUN contains the logical unit number for the SCSI
                   adapter.  For non-SCSI devices this field should be set to
                   zero.










          
                               Appendix A: Device Manager - ADD Interface  34




          
              AdapterFlags defines the adapter's characteristics.

                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³AdapterFlags      ³ Decription                    ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³AF_16M            ³ >16M Addresses Support        ³
                   ³                  ³ If set, this flag indicates   ³
                   ³                  ³ that the adapter supports     ³
                   ³                  ³ >16M addresses.               ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³AF_IBM_SCB        ³ IBM SCB Support               ³
                   ³                  ³ If set, this flag indicates   ³
                   ³                  ³ that the adapter supports     ³
                   ³                  ³ IBM SCB formatted             ³
                   ³                  ³ IOCC_ADAPTER_PASSTHRU         ³
                   ³                  ³ requests.                     ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³AF_HW_SCATGAT     ³ Hardware Scatter/Gather       ³
                   ³                  ³ If set, this flag indicates   ³
                   ³                  ³ that hardware supports        ³
                   ³                  ³ Scatter/Gather.               ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³AF_CHS_ADDRESSING ³ I/O Addressing                ³
                   ³                  ³ If set, this flag indicates   ³
                   ³                  ³ that the adapter supports     ³
                   ³                  ³ Cylinder/Head/Sector          ³
                   ³                  ³ addressing.                   ³
                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

              MaxHWSGList contains the maximum number of elements supported
                   by the hardware Scatter/Gather List.

              MaxCDBTransferLength contains the maximum number of bytes,
                   supported by this adapter, on a CDB - data transfer
                   request.

               UnitInfo[N] contains an array of UNITINFO structures.  The
                   number of elements in the array is determined by the
                   AdapterUnits field.
















          
                               Appendix A: Device Manager - ADD Interface  35




          
          þ   UNITINFO

              ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
              ³Field Name      ³C-Type³Length³Description             ³
              ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
              ³AdapterIndex    ³USHORT³ DW   ³Associated AdapterIndex ³
              ³UnitIndex       ³USHORT³ DW   ³Unit Tag                ³
              ³UnitFlags       ³USHORT³ DW   ³Unit Flags              ³
              ³Reserved        ³USHORT³ DW   ³Reserved                ³
              ³UnitHandle      ³USHORT³ DW   ³Assigned by ADD         ³
              ³FilterADDHandle ³USHORT³ DW   ³Handle of Filter ADD    ³
              ³UnitType        ³USHORT³ DW   ³Unit Type               ³
              ³QueuingCount    ³USHORT³ DW   ³IORB Queue Length       ³
              ³UnitSCSITargetID³UCHAR ³ DB   ³SCSI Target ID          ³
              ³UnitSCSILUN     ³UCHAR ³ DB   ³SCSI Logical Unit#      ³
              ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

              On exit from the ADD:

               AdapterIndex contains the unit's corresponding adapter's index
                   in the pAdapter[N] array.

               UnitIndex contains the unit's index in the UnitInfo[N] array.

               UnitFlags defines the unit's characteristics.

                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³UnitFlags      ³Decription                        ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³UF_REMOVABLE   ³Media Can Be Removed              ³
                   ³               ³If set, this flag indicates that  ³
                   ³               ³the unit's media is removable.    ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³UF_CHANGELINE  ³Changeline Supported              ³
                   ³               ³If set, this flag indicates that  ³
                   ³               ³the unit supports changeline      ³
                   ³               ³notification.                     ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³UF_PREFETCH    ³Read Prefetch Supported           ³
                   ³               ³If set, this flag indicates that  ³
                   ³               ³the unit supports read prefetch.  ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³UF_A_DRIVE     ³Manages Drive A                   ³
                   ³               ³If set, this flag indicates that  ³
                   ³               ³the unit manages drive A.         ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³UF_B_DRIVE     ³Manages Drive B                   ³
                   ³               ³If set, this flag indicates that  ³
                   ³               ³the unit manages drive B.         ³
                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ





          
                               Appendix A: Device Manager - ADD Interface  36




          
               UnitFlags defines the unit's characteristics (continued from
                   previous page).

                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³UnitFlags      ³Decription                        ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³UF_NODASD_SUPT ³Suppress DASD device manager      ³
                   ³               ³If set, this flag indicates that  ³
                   ³               ³the ADD does not want this unit   ³
                   ³               ³to be managed by the DASD Device  ³
                   ³               ³Manager.                          ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³UF_NOSCSI_SUPT ³Suppress SCSI device manager      ³
                   ³               ³If set, this flag indicates that  ³
                   ³               ³the ADD does not want this unit   ³
                   ³               ³to be managed by the SCSI Device  ³
                   ³               ³Manager.                          ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³UF_DEFECTIVE   ³Device is Defective               ³
                   ³               ³If set, this flag indicates that  ³
                   ³               ³the unit is non-operational.      ³
                   ³               ³Defective units are ignored by    ³
                   ³               ³the DASD and SCSI device managers.³
                   ³               ³However, the ADD should accept    ³
                   ³               ³allocation requests for the unit  ³
                   ³               ³and passes commands to the unit   ³
                   ³               ³for other device managers.        ³
                   ³               ³The information returned by the   ³
                   ³               ³IOCM_UNIT_STATUS command reflects ³
                   ³               ³this flag's current setting.      ³
                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

               Reserved this field is reserved for future growth.

               UnitHandle defines this unit's handle.  This handle is a
                   unique id, assigned by either the filter ADD or ADD.  A
                   unit is fully identified by the UnitHandle field and its
                   asociated ADD's handle, defined by either the
                   FilterADDHandle or ADDHandle field.

              FilterADDHandle contains the handle of the filter ADD.  If a
                   filter ADD does not exist, set this field to zero.













          
                               Appendix A: Device Manager - ADD Interface  37




          
               UnitType defines the unit's device type.

                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³UnitType               ³Devices Supported       ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³UIB_TYPE_DISK          ³Direct Access (DASD)    ³
                   ³UIB_TYPE_TAPE          ³Tape                    ³
                   ³UIB_TYPE_PRINTER       ³Printers                ³
                   ³UIB_TYPE_PROCESSOR     ³Processor               ³
                   ³UIB_TYPE_WORM          ³Write Once Read Many    ³
                   ³UIB_TYPE_CDROM         ³CD Rom                  ³
                   ³UIB_TYPE_SCANNER       ³Scanner                 ³
                   ³UIB_TYPE_OPTICAL_MEMORY³Optical Disk            ³
                   ³UIB_TYPE_CHANGER       ³Changers, (ex: juke box)³
                   ³UIB_TYPE_COMM          ³Communication           ³
                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

                   Note: One unit type should be set.

               QueuingCount defines the recommended number of commands to
                   queue for this unit.

               UnitSCSITargetID contains the target id, for SCSI devices.
                   For all other devices, this field equals zero.

               UnitSCSILUN contains the logical unit number, for SCSI
                   devices.  For all other devices, this field equals zero.



          Return Codes

          On exit, the ADD sets the Status and ErrorCode fields of the IORBH
          to reflect the results of the IOCC_CONFIGURATION request.

                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³IOCC_CONFIGURATION Error Codes                   ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³IOERR_CMD_SYNTAX                                 ³
                   ³IOERR_CMD_SW_RESOURCE                            ³
                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

          For a detailed description of all the return codes, refer to
          Appendix F, "Summary of Error Codes".











          
                               Appendix A: Device Manager - ADD Interface  38




          
          IOCC_UNIT_CONTROL

          The IOCC_UNIT_CONTROL CommandCode consists of all the
          CommandModifiers responsible for controlling the ownership of a
          unit.  The CommandModifiers are:

          þ   IOCM_ALLOCATE_UNIT

              Assigns ownership of the specified unit to the caller.  A unit
              must be allocated, prior to accepting any other direct call
              commands.  Once allocated, a unit may not be assigned to
              another owner until it is deallocated.  It is the
              responsibility of the owner to share a unit.

          þ   IOCM_DEALLOCATE_UNIT

              Removes the caller's ownership of the specified unit.  Once
              deallocated, a unit may be re-assigned to another caller.

          þ   IOCM_CHANGE_UNITINFO

              Updates the specified unit's UNITINFO portion of the
              DEVICETABLE with the information passed by the caller.  TBD



          Remarks

          þ   Support: Manditory
          þ   Called By: OS2DASD.SYS, OS2SCSI.SYS or filter ADD
          þ   Context of Call: INIT and TASK



          Format of IORB

          þ   IORB Type = IORB_UNIT_CONTROL
          þ   IORBH Fields
              -   RequestControl = All flags are disabled.
              -   CommandCode = IOCC_CONFIGURATION
              -   CommandModifier Options:
                  --  IOCM_ALLOCATE_UNIT
                  --  IOCM_DEALLOCATE_UNIT
                  --  IOCM_CHANGE_UNITINFO











          
                               Appendix A: Device Manager - ADD Interface  39




          
          IORB_UNIT_CONTROL Description

          This section defines the IORB_UNIT_CONTROL control block.

          þ   IORB_UNIT_CONTROL

              ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
              ³Field Name ³C-Type   ³Length³Description       ³
              ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
              ³iorbh      ³IORBH    ³DB(68)³IORB Header       ³
              ³Flags      ³USHORT   ³DW    ³Flags             ³
              ³pUnitInfo  ³PUNITINFO³DD    ³Ptr to UnitInfo   ³
              ³UnitInfoLen³USHORT DW³      ³Length of UnitInfo³
              ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

              On entry to the ADD:

               iorbh Refer to the "IORB General Format" section.

               Flags contains a zero.

               pUnitInfo contains a far pointer to a buffer containing
                   modified unit characteristics, in the format defined by
                   the UNITINFO structure.  The ADD uses this information to
                   update the unit's UNITINFO structure in the DEVICETABLE.
                   This field is only valid for the IOCM_CHANGE_UNITINFO
                   CommandModifier.

               UnitInfoLen contains the length, in bytes, of the UNITINFO
                   buffer (pUnitInfo) passed to the ADD.  This field is only
                   valid for the IOCM_CHANGE_UNITINFO CommandModifier.




          Return Codes

          On exit, the ADD sets the Status and ErrorCode fields of the IORBH
          to reflect the results of the IOCC_UNIT_CONTROL request.

                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³IOCC_UNIT_CONTROL Error Codes                    ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³IOERR_CMD_NOT_SUPPORTED                          ³
                   ³IOERR_CMD_SYNTAX                                 ³
                   ³IOERR_CMD_SW_RESOURCE                            ³
                   ³IOERR_UNIT_NOT_ALLOCATED                         ³
                   ³IOERR_UNIT_ALLOCATED                             ³
                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

          For a detailed description of all the return codes, refer to
          Appendix F, "Summary of Error Codes".



          
                               Appendix A: Device Manager - ADD Interface  40




          
          IOCC_GEOMETRY

          The IOCC_GEOMETRY CommandCode consists of all the CommandModifiers
          responsible for setting/returning information about the capacity of
          a unit.  The CommandModifiers are:

          þ   IOCM_GET_MEDIA_GEOMETRY

              Returns the geometry of the current media in a drive.

          þ   IOCM_SET_MEDIA_GEOMETRY

              Sets the media's geometry.

          þ   IOCM_GET_DEVICE_GEOMETRY

              Returns the device geometry, compatible with DOS.  If the ADD
              supports translation, the 'virtual' geometry of the device
              should be returned with the additional translation preformed
              internally.


          þ   IOCM_SET_LOGICAL_GEOMETRY

              Sets the logical geometry. This support is manditory only for
              standard diskette media.



          Remarks

          þ   Support: Manditory (See CommmandModifiers for exceptions.)
          þ   Called By: OS2DASD.SYS, OS2SCSI.SYS or filter ADD
          þ   Context of Call: INIT and TASK




          Format of IORB

          þ   IORB Type = IORB_GEOMETRY
          þ   IORBH Fields
              -   RequestControl = All flags are disabled.
              -   CommandCode = IOCC_GEOMETRY
              -   CommandModifier Options:
                  --  IOCM_GET_MEDIA_GEOMETRY
                  --  IOCM_SET_MEDIA_GEOMETRY
                  --  IOCM_GET_DEVICE_GEOMETRY







          
                               Appendix A: Device Manager - ADD Interface  41




          
          IOCC_GEOMETRY Description

          This section defines the IORB_GEOMETRY and GEOMETRY control blocks.

          þ   IORB_GEOMETRY

              ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
              ³Field Name ³C-Type   ³Length³Description        ³
              ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
              ³iorbh      ³IORBH    ³DB(68)³IORB Header        ³
              ³pGeometry  ³PGEOMETRY³DD    ³Ptr to GEOMETRY    ³
              ³GeometryLen³ULONG    ³DD    ³Length of GEOMETRY ³
              ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

              On entry to the ADD:

               iorbh Refer to the "IORB General Format" section.

               pGeometry contains a far pointer to the block of storage
                   (length = GeometryLen), allocated by the caller, for the
                   GEOMETRY.

               GeometryLen contains the size, in bytes, of the block of
                   storage for the GEOMETRY structure (pGeometry).

          þ   GEOMETRY

              ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
              ³Field Name      ³C-Type³Length³Description             ³
              ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
              ³TotalSectors    ³ULONG ³ DD   ³# of Sectors            ³
              ³BytesPerSector  ³USHORT³ DW   ³Bytes Per Sector        ³
              ³Reserved        ³USHORT³ DW   ³Reserved                ³
              ³NumHeads        ³USHORT³ DW   ³# of Heads              ³
              ³TotalCylinders  ³ULONG ³ DD   ³# of Cylinders          ³
              ³SectorsPerTrack ³USHORT³ DW   ³# of Sectors Per Track  ³
              ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

              On entry to the ADD for "SET" CommandModifiers and on exit from
              the ADD for "GET" CommandModifiers:

               TotalSectors contains the total number of sectors.

               BytesPerSector contains the number of bytes per sector.  The
                   IBM OS/2 2.0, file system, only supports a value of 512.

               Reserved contains a zero.  This alignment field ensures that
                   the GEOMETRY structure aligns with SCSI Read Capacity
                   output.

               NumHeads contains the number of heads.




          
                               Appendix A: Device Manager - ADD Interface  42




          
               TotalCylinders contains the number of cylinders.

               SectorsPerTrack contains the number of sectors per track.




          Return Codes

          On exit, the ADD sets the Status and ErrorCode fields of the IORBH
          to reflect the results of the IOCC_GEOMETRY request.

                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³IOCC_GEOMETRY Error Codes - TBD                  ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³IOERR_CMD_NOT_SUPPORTED                          ³
                   ³IOERR_CMD_SYNTAX                                 ³
                   ³IOERR_CMD_SW_RESOURCE                            ³
                   ³IOERR_UNIT_NOT_ALLOCATED                         ³
                   ³IOERR_UNIT_NOT_READY                             ³
                   ³IOERR_UNIT_PWR_OFF                               ³
                   ³IOERR_MEDIA_NOT_FORMATTED                        ³
                   ³IOERR_MEDIA_NOT_SUPPORTED                        ³
                   ³IOERR_MEDIA_WRITE_PROTECT                        ³
                   ³IOERR_MEDIA_CHANGED                              ³
                   ³IOERR_MEDIA_NOT_PRESENT                          ³
                   ³IOERR_ADAPTER_HOSTBUSCHECK                       ³
                   ³IOERR_ADAPTER_DEVICEBUSCHECK                     ³
                   ³IOERR_ADAPTER_OVERRUN                            ³
                   ³IOERR_ADAPTER_UNDERRUN                           ³
                   ³IOERR_ADAPTER_DIAGFAIL                           ³
                   ³IOERR_ADAPTER_TIMEOUT                            ³
                   ³IOERR_ADAPTER_DEVICE_TIMEOUT                     ³
                   ³IOERR_ADAPTER_REQ_NOT_SUPPORTED                  ³
                   ³IOERR_ADAPTER_REFER_TO_STATUS                    ³
                   ³IOERR_DEVICE_DEVICEBUSCHECK                      ³
                   ³IOERR_DEVICE_REQ_NOT_SUPPORTED                   ³
                   ³IOERR_DEVICE_DIAGFAIL                            ³
                   ³IOERR_DEVICE_BUSY                                ³
                   ³IOERR_DEVICE_OVERRUN                             ³
                   ³IOERR_DEVICE_UNDERRUN                            ³
                   ³IOERR_DEVICE_RESET                               ³
                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

          For a detailed description of all the return codes, refer to
          Appendix F, "Summary of Error Codes".









          
                               Appendix A: Device Manager - ADD Interface  43




          
          IOCC_EXECUTE_IO

          The IOCC_EXECUTE_IO CommandCode consists of all CommandModifiers
          responsible for issuing a read or write to a unit.  The
          CommandModifiers are:

          þ   IOCM_READ

              Reads a unit's data into the scatter/gather list's buffer(s).

          þ   IOCM_READ_VERIFY

              Verifies that the recorded data at the requested I/O address is
              readable, without transferring any data.

          þ   IOCM_READ_PREFETCH

              Reads data from the device into the adapter's hardware cache.
              This command is optional.

          þ   IOCM_WRITE

              Writes data from the scatter/gather list's buffer(s) to the
              unit's specified I/O address.

          þ   IOCM_WRITE_VERIFY

              Writes data from the scatter/gather list's buffer(s) to the
              unit's specified I/O address and then verifies that the data
              can be read (write/read verify combination).




          Remarks

          þ   Support: Mandatory
          þ   Called By: OS2DASD.SYS, OS2SCSI.SYS or filter ADD
          þ   Context of Call: TASK and INTERRUPT




          Format of IORB

          þ   IORB Type = IORB_EXECUTEIO
          þ   IORBH Fields
              -   RequestControl = Flags may be enabled or disabled.
              -   CommandCode = IOCC_EXECUTE_IO
              -   CommandModifier Options:
                  --  IOCM_READ
                  --  IOCM_READ_VERIFY
                  --  IOCM_READ_PREFETCH
                  --  IOCM_WRITE

          
                               Appendix A: Device Manager - ADD Interface  44




          
                  --  IOCM_WRITE_VERIFY


          IORB_EXECUTEIO Description

          This section defines the IORB_EXECUTEIO control block.

          þ   IORB_EXECUTEIO

              ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
              ³Field Name     ³C-Type       ³Length³Description        ³
              ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
              ³iorbh          ³IORBH        ³DB(68)³IORB Header        ³
              ³cSGLIST        ³USHORT       ³DW    ³# of Elements      ³
              ³pSGLIST        ³PSCATGATENTRY³DD    ³Ptr to S/G List    ³
              ³ppSGLIST       ³ULONG        ³DD    ³Ptr to S/G List    ³
              ³RBA            ³ULONG        ³DD    ³I/O Starting Addr  ³
              ³BlockCount     ³USHORT       ³DW    ³Sector Count       ³
              ³BlocksXferred  ³USHORT       ³DW    ³# of Sector xfer   ³
              ³BlockSize      ³USHORT       ³DW    ³# of Bytes/Sector  ³
              ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

              On entry to the ADD:

               iorbh Refer to the "IORB General Format" section.

               cSGList contains the number of scatter/gather elements in the
                   Scatter/Gather List (pSGLIST).

               pSGLIST contains a far pointer to the Scatter/Gather List,
                   supplied by the caller.  The Scatter/Gather List consists
                   of an array of cSGList elements, each pointing to a
                   pysically contiguous area of real memory in format defined
                   by the SCATGATENTRY structure.

                   SCATGATENTRY Structure
                   ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³Field Name³C-Type³Length³Description           ³
                   ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³ppXferBuf ³ULONG ³ DD   ³Physical Ptr to Buffer³
                   ³XferBufLen³ULONG ³ DD   ³Length of buffer      ³
                   ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

               ppSGLIST contains a 32-bit physical address of the
                   Scatter/Gather List.










          
                               Appendix A: Device Manager - ADD Interface  45




          
               RBA contains the starting relative block address for the data
                   transfer operation.  If the IORBH, RequestControl -
                   IORB_CHS_ADDRESSING flag is set, then the format of the
                   RBA field is defined by the CHS_ADDR structure.

                   CHS_ADDR Structure
                   ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³Field Name³C-Type³Length³Description      ³
                   ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³Cylinder  ³USHORT³ DW   ³Starting Cylinder³
                   ³Head      ³UCHAR ³ DB   ³Starting Head    ³
                   ³Sector    ³UCHAR ³ DB   ³Starting Sector  ³
                   ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

               BlockCount contains the number of sectors (length = BlockSize)
                   to transfer.

                   Note: If this value exceeds the adapter's maximum transfer
                   size, the ADD is responsible for issuing multiple
                   operations to the unit to complete the caller's request.

               BlocksXferred equals zero, on entry.  On exit from the ADD,
                   the BlocksXferred contains the number of sectors
                   successfully transferred.

               BlockSize contains the number of bytes in a block or a sector.
                   The IBM OS/2 2.0, file system, only supports a value of
                   512.

              Note: The scatter/gather list related fields (cSGLIST, pSGLIST,
              and ppSGLIST) are at the same offset as its equivalent pointers
              in the IOCC_ADAPTER_PASSTHRU and IOCC_FORMAT CommandCodes.























          
                               Appendix A: Device Manager - ADD Interface  46




          
          Return Codes

          On exit, the ADD sets the Status an ErrorCode fields of the IORBH
          to reflect the results of the IOCC_EXECUTE_IO request.

                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³IOCC_EXECUTE_IO Error Codes                      ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³IOERR_CMD_NOT_SUPPORTED                          ³
                   ³IOERR_CMD_SYNTAX                                 ³
                   ³IOERR_CMD_SGLIST_BAD                             ³
                   ³IOERR_CMD_SW_RESOURCE                            ³
                   ³IOERR_CMD_ABORTED                                ³
                   ³IOERR_UNIT_NOT_ALLOCATED                         ³
                   ³IOERR_UNIT_NOT_READY                             ³
                   ³IOERR_UNIT_PWR_OFF                               ³
                   ³IOERR_RBA_ADDRESSING_ERROR                       ³
                   ³IOERR_RBA_LIMIT                                  ³
                   ³IOERR_RBA_CRC_ERROR                              ³
                   ³IOERR_MEDIA_NOT_FORMATTED                        ³
                   ³IOERR_MEDIA_NOT_SUPPORTED                        ³
                   ³IOERR_MEDIA_WRITE_PROTECT                        ³
                   ³IOERR_MEDIA_CHANGED                              ³
                   ³IOERR_MEDIA_NOT_PRESENT                          ³
                   ³IOERR_ADAPTER_HOSTBUSCHECK                       ³
                   ³IOERR_ADAPTER_DEVICEBUSCHECK                     ³
                   ³IOERR_ADAPTER_OVERRUN                            ³
                   ³IOERR_ADAPTER_UNDERRUN                           ³
                   ³IOERR_ADAPTER_DIAGFAIL                           ³
                   ³IOERR_ADAPTER_TIMEOUT                            ³
                   ³IOERR_ADAPTER_DEVICE_TIMEOUT                     ³
                   ³IOERR_ADAPTER_REQ_NOT_SUPPORTED                  ³
                   ³IOERR_ADAPTER_REFER_TO_STATUS                    ³
                   ³IOERR_DEVICE_DEVICEBUSCHECK                      ³
                   ³IOERR_DEVICE_REQ_NOT_SUPPORTED                   ³
                   ³IOERR_DEVICE_DIAGFAIL                            ³
                   ³IOERR_DEVICE_BUSY                                ³
                   ³IOERR_DEVICE_OVERRUN                             ³
                   ³IOERR_DEVICE_UNDERRUN                            ³
                   ³IOERR_DEVICE_RESET                               ³
                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

          For a detailed description of all the return codes, refer to
          Appendix F, "Summary of Error Codes".











          
                               Appendix A: Device Manager - ADD Interface  47




          
          IOCC_FORMAT

          The IOCC_FORMAT CommandCode consists of all CommandModifiers
          responsible for unit format requests.  The CommandModifiers are:

          þ   IOCM_FORMAT_MEDIA

              Formats the entire media in the unit.

          þ   IOCM_FORMAT_TRACK

              Formats the specified track on the unit.

          þ   IOCM_FORMAT_PROGRESS

              Returns the status of the unit's format in progress.  This
              support is optional.  (TBD - format of progress information
              return)




          Remarks

          þ   Support: Mandatory if hardware requires
          þ   Called By: OS2DASD.SYS, OS2SCSI.SYS or filter ADD
          þ   Context of Call: TASK




          Format of IORB

          þ   IORB Type = IORB_FORMAT
          þ   IORBH Fields
              -   RequestControl = Flags may be enabled or disabled.
              -   CommandCode = IOCC_FORMAT
              -   CommandModifier Options:
                  --  IOCM_FORMAT_MEDIA
                  --  IOCM_FORMAT_TRACK
                  --  IOCM_FORMAT_PROGRESS














          
                               Appendix A: Device Manager - ADD Interface  48




          
          IORB_FORMAT Description

          This section defines the IORB_FORMAT control block.

          þ   IORB_FORMAT

              ÚÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
              ³Field Name  ³C-Type       ³Length³Description         ³
              ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
              ³iorbh       ³IORBH        ³DB(68)³IORB Header         ³
              ³cSGLIST     ³USHORT       ³DW    ³# of Elements       ³
              ³pSGLIST     ³PSCATGATENTRY³DD    ³Ptr to S/G List     ³
              ³ppSGLIST    ³ULONG        ³DD    ³Ptr to S/G List     ³
              ³FormatCmdLen³USHORT       ³DW    ³length of Format Cmd³
              ³pFormatCmd  ³PBYTE        ³DD    ³Ptr to Format Cmd   ³
              ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

              On entry to the ADD:

               iorbh Refer to the "IORB General Format" section.

               cSGList contains the number of scatter/gather elements in the
                   Scatter/Gather List (pSGLIST).

               pSGLIST contains a far pointer to the Scatter/Gather List,
                   supplied by the caller.  The Scatter/Gather List consists
                   of an array of cSGList elements, each pointing to a
                   pysically contiguous area of real memory in format defined
                   by the SCATGATENTRY structure.

                   SCATGATENTRY Structure
                   ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³Field Name³C-Type³Length³Description           ³
                   ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³ppXferBuf ³ULONG ³ DD   ³Physical Ptr to Buffer³
                   ³XferBufLen³ULONG ³ DD   ³Length of buffer      ³
                   ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

               ppSGLIST contains a 32-bit physical address of the
                   Scatter/Gather List.

               FormatCmdLen contains the length, in bytes, of the format
                   command (pFormatCmd).












          
                               Appendix A: Device Manager - ADD Interface  49




          
               pFormatCmd contains a pointer to device specific formatting
                   information.  For diskette controllers, this points the to
                   the FORMAT_CMD_TRACK structure.  For SCSI devices, this
                   points to the SCSI CDB for the unit.

                   FORMAT_CMD_TRACK Structure
                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³Field Name   ³C-Type³Length³Description        ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³flags        ³USHORT³ DW   ³Flags              ³
                   ³RBA          ³ULONG ³ DD   ³Starting RBA       ³
                   ³cTrackEntries³USHORT³ DW   ³# of Track Entries ³
                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

                   On entry to the ADD:

                    flags contains flags to define the request.

                        ÚÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                        ³Flags    ³Description                   ³
                        ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                        ³FF_VERIFY³Verify After Format           ³
                        ³         ³If set, this flag indicates   ³
                        ³         ³that the ADD should verify    ³
                        ³         ³the sectors after formatting. ³
                        ÀÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

                    RBA contains the starting relative block address for a
                        IOCM_FORMAT_TRACK request.  For IOCM_FORMAT_MEDIA and
                        IOCM_FORMAT_PROGRESS requests this field equals 0.
                        If the IORBH, RequestControl - IORB_CHS_ADDRESSING
                        flag is set, then the format of the RBA field is
                        defined by the CHS_ADDR structure.

                        CHS_ADDR Structure
                        ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                        ³Field Name³C-Type³Length³Description      ³
                        ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                        ³Cylinder  ³USHORT³ DW   ³Starting Cylinder³
                        ³Head      ³UCHAR ³ DB   ³Starting Head    ³
                        ³Sector    ³UCHAR ³ DB   ³Starting Sector  ³
                        ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

                   cTrackEntries contains the number of track entries to
                        format for a IOCM_FORMAT_TRACK request.  For
                        IOCM_FORMAT_MEDIA and IOCM_FORMAT_PROGRESS requests
                        this field equals 0.


              Note: The scatter/gather list related fields (cSGLIST, pSGLIST,
              and ppSGLIST) are at the same offset as its equivalent pointers
              in the IOCC_EXECUTE_IO and IOCC_ADAPTER_PASSTHRU CommandCodes.



          
                               Appendix A: Device Manager - ADD Interface  50




          





















                                Intentionally Left Blank

































          
                               Appendix A: Device Manager - ADD Interface  51




          
          Return Codes

          On exit, the ADD sets the Status and ErrorCode fields of the IORBH
          to reflect the results of the IOCC_FORMAT request.

                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³IOCC_FORMAT Error Codes                          ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³IOERR_CMD_NOT_SUPPORTED                          ³
                   ³IOERR_CMD_SYNTAX                                 ³
                   ³IOERR_CMD_SW_RESOURCE                            ³
                   ³IOERR_CMD_ABORTED                                ³
                   ³IOERR_UNIT_NOT_ALLOCATED                         ³
                   ³IOERR_UNIT_NOT_READY                             ³
                   ³IOERR_UNIT_PWR_OFF                               ³
                   ³IOERR_RBA_ADDRESSING_ERROR                       ³
                   ³IOERR_RBA_LIMIT                                  ³
                   ³IOERR_RBA_CRC_ERROR                              ³
                   ³IOERR_MEDIA_NOT_SUPPORTED                        ³
                   ³IOERR_MEDIA_WRITE_PROTECT                        ³
                   ³IOERR_MEDIA_CHANGED                              ³
                   ³IOERR_MEDIA_NOT_PRESENT                          ³
                   ³IOERR_ADAPTER_HOSTBUSCHECK                       ³
                   ³IOERR_ADAPTER_DEVICEBUSCHECK                     ³
                   ³IOERR_ADAPTER_OVERRUN                            ³
                   ³IOERR_ADAPTER_UNDERRUN                           ³
                   ³IOERR_ADAPTER_DIAGFAIL                           ³
                   ³IOERR_ADAPTER_TIMEOUT                            ³
                   ³IOERR_ADAPTER_DEVICE_TIMEOUT                     ³
                   ³IOERR_ADAPTER_REQ_NOT_SUPPORTED                  ³
                   ³IOERR_ADAPTER_REFER_TO_STATUS                    ³
                   ³IOERR_DEVICE_DEVICEBUSCHECK                      ³
                   ³IOERR_DEVICE_REQ_NOT_SUPPORTED                   ³
                   ³IOERR_DEVICE_DIAGFAIL                            ³
                   ³IOERR_DEVICE_BUSY                                ³
                   ³IOERR_DEVICE_OVERRUN                             ³
                   ³IOERR_DEVICE_UNDERRUN                            ³
                   ³IOERR_DEVICE_RESET                               ³
                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

          For a detailed description of all the return codes, refer to
          Appendix F, "Summary of Error Codes".













          
                               Appendix A: Device Manager - ADD Interface  52




          
          IOCC_UNIT_STATUS

          The IOCC_UNIT_STATUS CommandCode consists of all the
          CommandModifiers responsible for returning a unit's current state.
          The CommandModifiers are:

          þ   IOCM_GET_UNIT_STATUS

              Returns flags indicating the unit's current ready, power on
              and defective status.

          þ   IOCM_GET_CHANGELINE_STATE

              Returns the unit's current changeline state.  This command is
              mandatory for removable media only.

          þ   IOCM_GET_MEDIA_SENSE

              Returns the unit's current media's storage capacity.  This
              command is manditory for standard diskette devices.




          Remarks

          þ   Support: Manditory (See CommmandModifiers for exceptions.)
          þ   Called By: OS2DASD.SYS, OS2SCSI.SYS or filter ADD
          þ   Context of Call: TASK




          Format of IORB

          þ   IORB Type = IORB_UNIT_STATUS
          þ   IORBH Fields
              -   RequestControl = All flags are disabled.
              -   CommandCode = IOCC_UNIT_STATUS
              -   CommandModifier Options:
                  --  IOCM_GET_UNIT_STATUS
                  --  IOCM_GET_CHANGELINE_STATE
                  --  IOCM_GET_MEDIA_SENSE












          
                               Appendix A: Device Manager - ADD Interface  53




          
          IORB_UNIT_STATUS Description

          This section defines the IORB_UNIT_STATUS control block.

          þ   IORB_UNIT_STATUS

              ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
              ³Field Name³C-Type³Length³Description             ³
              ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
              ³iorbh     ³IORBH ³DB(68)³IORB Header             ³
              ³UnitStatus³USHORT³DW    ³Unit Status             ³
              ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

              On entry to the ADD:

               iorbh Refer to the "IORB General Format" section.

               UnitStatus equals zero, on entry. On exit from the ADD, this
                   field contains status information request, based on the
                   CommandModifier field.

                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³UnitStatus               ³Description            ³
                   ³By Command Modifier      ³                       ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³IOCM_GET_UNIT_STATUS     ³                       ³
                   ³    US_READY             ³Unit In Ready State    ³
                   ³    US_POWER             ³Unit Powered On        ³
                   ³    US_DEFECTIVE         ³Unit Defective         ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³IOCM_GET_CHANGELINE_STATE³                       ³
                   ³    US_CHANGELINE_ACTIVE ³Changeline Occurred    ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³IOCM_GET_MEDIA_SENSE     ³                       ³
                   ³    US_MEDIA_144MB       ³144KB Media Capacity   ³
                   ³    US_MEDIA_288MB       ³288KB Media Capacity   ³
                   ³    US_MEDIA_720KB       ³720KB Media Capacity   ³
                   ³    US_MEDIA_UNKNOWN     ³Media Capacity Unknown ³
                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
















          
                               Appendix A: Device Manager - ADD Interface  54




          
          Return Codes

          On exit, the ADD sets the Status and ErrorCode fields of the IORBH
          to reflect the results of the IOCC_UNIT_STATUS request.

                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³IOCC_UNIT_STATUS Error Codes                     ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³IOERR_CMD_NOT_SUPPORTED                          ³
                   ³IOERR_CMD_SYNTAX                                 ³
                   ³IOERR_CMD_SW_RESOURCE                            ³
                   ³IOERR_UNIT_NOT_ALLOCATED                         ³
                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

          For a detailed description of all the return codes, refer to
          Appendix F, "Summary of Error Codes".







































          
                               Appendix A: Device Manager - ADD Interface  55




          
          IOCC_DEVICE_CONTROL

          The IOCC_DEVICE_CONTROL CommandCode consists of all the
          CommmandModifiers responsible for device control.  The
          CommandModifiers are:

          þ   IOCM_ABORT

              Aborts the unit's current operation. Mandatory for SCSI
              devices.

          þ   IOCM_RESET

              Resets the unit to its default operating parameters.  Manditory
              for SCSI devices.

          þ   IOCM_SUSPEND

              Suspends the unit's current operation. Mandatory for floppy
              devices.

          þ   IOCM_RESUME

              Resumes the unit's suspended operation. Mandatory for floppy
              devices.

          þ   IOCM_LOCK_MEDIA

              Locks the current media in the unit. Mandatory for removable
              media.

          þ   IOCM_UNLOCK_MEDIA

              Unlocks the current media from the unit. Mandatory for
              removable media.



          Remarks

          þ   Support: Mandatory for the SCSI, floppy and removable media
              devices (See CommmandModifiers for exceptions.)
          þ   Called By: OS2DASD.SYS, OS2SCSI.SYS or filter ADD
          þ   Context of Call: TASK











          
                               Appendix A: Device Manager - ADD Interface  56




          
          Format of IORB

          þ   IORB Type = IORB_DEVICE_CONTROL
          þ   IORBH Fields
              -   RequestControl = All flags are disabled.
              -   CommandCode = IOCC_DEVICE_CONTROL
              -   CommandModifier Options:
                  --  IOCM_ABORT
                  --  IOCM_RESET
                  --  IOCM_SUSPEND
                  --  IOCM_RESUME
                  --  IOCM_LOCK_MEDIA
                  --  IOCM_UNLOCK_MEDIA


          IORB_DEVICE_CONTROL Description

          This section defines the IORB_DEVICE_CONTROL control block.

          þ   IORB_DEVICE_CONTROL

              ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
              ³Field Name³C-Type³Length³Description   ³
              ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
              ³iorbh     ³IORBH ³DB(68)³IORB Header   ³
              ³Flags     ³USHORT³DD    ³Flags         ³
              ³Reserved  ³USHORT³DD    ³Reserved      ³
              ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

              On entry to the ADD:

               iorbh Refer to the "IORB General Format" section.

               Flags contains flags defined only for IOCM_SUSPEND requests.
                   For all other requests, this field equals zero.

                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³IOCM_SUSPEND Flags   ³ Description                ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³DC_SUSPEND_DEFERRED  ³ Suspend On Idle            ³
                   ³                     ³ If set, this flag indicates³
                   ³                     ³ that the suspend should    ³
                   ³                     ³ occur once the unit is     ³
                   ³                     ³ idle.                      ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³DC_SUSPEND_IMMEDIATE ³ Suspend Immediate          ³
                   ³                     ³ If set, this flag indicates³
                   ³                     ³ that the suspend should    ³
                   ³                     ³ occur once the current     ³
                   ³                     ³ request is completed.      ³
                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

               RESERVED contains a zero.


          
                               Appendix A: Device Manager - ADD Interface  57




          























































          
                               Appendix A: Device Manager - ADD Interface  58




          
          Return Codes

          On exit, the ADD sets the Status and ErrorCode fields of the IORBH
          to reflect the results of the IOCC_DEVICE_CONTROL request.

                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³IOCC_DEVICE_CONTROL Error Codes - TBD            ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³IOERR_CMD_NOT_SUPPORTED                          ³
                   ³IOERR_CMD_SYNTAX                                 ³
                   ³IOERR_CMD_SW_RESOURCE                            ³
                   ³IOERR_UNIT_NOT_ALLOCATED                         ³
                   ³IOERR_UNIT_NOT_READY                             ³
                   ³IOERR_UNIT_PWR_OFF                               ³
                   ³IOERR_ADAPTER_HOSTBUSCHECK                       ³
                   ³IOERR_ADAPTER_DEVICEBUSCHECK                     ³
                   ³IOERR_ADAPTER_OVERRUN                            ³
                   ³IOERR_ADAPTER_UNDERRUN                           ³
                   ³IOERR_ADAPTER_DIAGFAIL                           ³
                   ³IOERR_ADAPTER_TIMEOUT                            ³
                   ³IOERR_ADAPTER_DEVICE_TIMEOUT                     ³
                   ³IOERR_ADAPTER_REQ_NOT_SUPPORTED                  ³
                   ³IOERR_ADAPTER_REFER_TO_STATUS                    ³
                   ³IOERR_DEVICE_DEVICEBUSCHECK                      ³
                   ³IOERR_DEVICE_REQ_NOT_SUPPORTED                   ³
                   ³IOERR_DEVICE_DIAGFAIL                            ³
                   ³IOERR_DEVICE_BUSY                                ³
                   ³IOERR_DEVICE_OVERRUN                             ³
                   ³IOERR_DEVICE_UNDERRUN                            ³
                   ³IOERR_DEVICE_RESET                               ³
                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

          For a detailed description of all the return codes, refer to
          Appendix F, "Summary of Error Codes".





















          
                               Appendix A: Device Manager - ADD Interface  59




          
          IOCC_ADAPTER_PASSTHRU

          The IOCC_ADAPTER_PASSTHRU CommandCode consists of all the
          CommandModifiers responsible for issuing SCSI formatted requests to
          a unit.  The CommandModifiers are:

          þ   IOCM_EXECUTE_SCB

              Issues a SCB formatted request to the specified unit.  This
              command is manditory for IBM SCSI units.

          þ   IOCM_EXECUTE_CDB

              Issues a CDB formatted request to the specified unit.  This
              command is mandatory for all SCSI units.




          Remarks

          þ   Support: Mandatory for SCSI units (See CommmandModifiers for
              exceptions.)
          þ   Called By: OS2SCSI.SYS or filter ADD
          þ   Context of Call: TASK and INTERRUPT





          Format of IORB

          þ   IORB Type = IORB_ADAPTER_PASSTHRU
          þ   IORBH Fields
              -   RequestControl = All flags may be enabled or disabled.
              -   CommandCode = IOCC_ADAPTER_PASSTHRU
              -   CommandModifier Options:
                  --  IOCM_EXECUTE_SCB
                  --  IOCM_EXECUTE_CDB
















          
                               Appendix A: Device Manager - ADD Interface  60




          
          IORB_ADAPTER_PASSTHRU Description

          This section defines the IORB_ADAPTER_PASSTHRU control block.

          þ   IORB_ADAPTER_PASSTHRU

              ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
              ³Field Name         ³C-Type       ³Length³Description    ³
              ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
              ³iorbh              ³IORBH        ³DB(68)³IORB Header    ³
              ³cSGLIST            ³USHORT       ³DW    ³# of Elements  ³
              ³pSGLIST            ³PSCATGATENTRY³DD    ³S/G List Ptr   ³
              ³ppSGLIST           ³ULONG        ³DD    ³S/G List Ptr   ³
              ³ControllerCmdLen   ³USHORT       ³DW    ³Length         ³
              ³pControllerCmd     ³PBYTE        ³DD    ³Controller Ptr ³
              ³Flags              ³USHORT       ³DW    ³Flags          ³
              ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

              On entry to the ADD:

               iorbh Refer to the "IORB General Format" section.

               cSGList contains the number of scatter/gather elements in the
                   Scatter/Gather List (pSGLIST), for IOCM_EXECUTE_CDB
                   requests.  For all other requests this field contains a
                   zero.

               pSGLIST contains a far pointer to the Scatter/Gather List,
                   supplied by the caller, for IOCM_EXECUTE_CDB requests.
                   For all other requests this field contains a zero.  The
                   Scatter/Gather List consists of an array of cSGList
                   elements, each pointing to a pysically contiguous area of
                   real memory in format defined by the SCATGATENTRY
                   structure.

                   SCATGATENTRY Structure
                   ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³Field Name³C-Type³Length³Description           ³
                   ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³ppXferBuf ³ULONG ³ DD   ³Physical Ptr to Buffer³
                   ³XferBufLen³ULONG ³ DD   ³Length of buffer      ³
                   ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

               ppSGLIST contains a 32-bit physical address of the
                   Scatter/Gather List, for IOCM_EXECUTE_CDB requests.  For
                   all other requests this field contains a zero.









          
                               Appendix A: Device Manager - ADD Interface  61




          
               ControllerCmdLen contains the length, in bytes, of the command
                   controller buffer.

               pControllerCmd contains a pointer to the controller command
                   buffer in either the SCB or CDB format, based on the
                   CommandModifier field.

               Flags contains flags to define the request.

                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³Flags           ³ Description                     ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³PT_DIRECTION_IN ³ Data Transfer Direction         ³
                   ³                ³ This flag defines the direction ³
                   ³                ³ of the data transfer for        ³
                   ³                ³ IOCM_EXECUTE_CDB requests.      ³
                   ³                ³ If set, the data transfer is    ³
                   ³                ³ from the target device to the   ³
                   ³                ³ host adapter.  For all other    ³
                   ³                ³ requests this flag is ignored.  ³
                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

              Note: The scatter/gather list related fields (cSGLIST, pSGLIST,
              and ppSGLIST) are at the same offset as its equivalent pointers
              in the IOCC_EXECUTE_IO and IOCC_FORMAT CommandCodes.






























          
                               Appendix A: Device Manager - ADD Interface  62




          
          Return Codes

          On exit, the ADD sets the Status and ErrorCode fields of the IORBH
          to reflect the results of the IOCC_ADAPTER_PASSTHRU request.

                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³IOCC_ADAPTER_PASSTHRU Error Codes                ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³IOERR_CMD_NOT_SUPPORTED                          ³
                   ³IOERR_CMD_SYNTAX                                 ³
                   ³IOERR_CMD_SGLIST_BAD                             ³
                   ³IOERR_CMD_SW_RESOURCE                            ³
                   ³IOERR_CMD_ABORTED                                ³
                   ³IOERR_UNIT_NOT_ALLOCATED                         ³
                   ³IOERR_UNIT_NOT_READY                             ³
                   ³IOERR_UNIT_PWR_OFF                               ³
                   ³IOERR_ADAPTER_HOSTBUSCHECK                       ³
                   ³IOERR_ADAPTER_DEVICEBUSCHECK                     ³
                   ³IOERR_ADAPTER_OVERRUN                            ³
                   ³IOERR_ADAPTER_UNDERRUN                           ³
                   ³IOERR_ADAPTER_DIAGFAIL                           ³
                   ³IOERR_ADAPTER_TIMEOUT                            ³
                   ³IOERR_ADAPTER_DEVICE_TIMEOUT                     ³
                   ³IOERR_ADAPTER_REQ_NOT_SUPPORTED                  ³
                   ³IOERR_ADAPTER_REFER_TO_STATUS                    ³
                   ³IOERR_DEVICE_DEVICEBUSCHECK                      ³
                   ³IOERR_DEVICE_REQ_NOT_SUPPORTED                   ³
                   ³IOERR_DEVICE_DIAGFAIL                            ³
                   ³IOERR_DEVICE_BUSY                                ³
                   ³IOERR_DEVICE_OVERRUN                             ³
                   ³IOERR_DEVICE_UNDERRUN                            ³
                   ³IOERR_DEVICE_RESET                               ³
                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

          For a detailed description of all the return codes, refer to
          Appendix F, "Summary of Error Codes".



















          
                               Appendix A: Device Manager - ADD Interface  63




          
          REGISTERDEVICECLASS

          At INIT time, the ADD calls the RegisterDeviceClass devhlp to
          register its direct call command handler entry point with the
          kernel.


          Processing

               LDS  SI, ADD_Name            ; DS:SI = Ptr ADD to ASCIIZ name
                                            ;         maximum of 16 chars
               MOV  AX,SEGMENT ADD_Function ; AX:BX = Ptr to ADD's Direct Call
               LEA  BX,ADD_Function         ;         Command Handler
               MOV  DI,Device_Flags         ; Must be zero for DISK ADDs
               MOV  CX,Device_Class         ; Must be one for DISK ADDs
               MOV  DL,DevHlp_RegisterADD
               CALL [Device_Help]



          Results

               'C' Cleared if successful
                   AX = ADDHandle
               'C' Set if error
                   AX = ERROR_NOT_ENOUGH_MEMORY
                            if CX out of range
                            if table is full



























          
                               Appendix A: Device Manager - ADD Interface  64




          
          GETDOSVAR

          The existing GetDOSVar devhlp has been modified to return a pointer
          to the device class table for a specified device class.  This
          pointer is valid at init, task and interrupt time, and is used by
          the device managers or filter ADDs to obtain the ADD entry points
          from the kernel.


          Processing

               MOV  AL,DHGETDOSV_DEVICECLASSTABLE  ; Device Class table index
               MOV  CX,Device_Class                ; Must be one for DISK ADDs
               MOV  DL,DevHlp_GetDOSVar
               CALL [Device_Help]



          Results

               'C' Cleared if successful
                   AX:BX = global ptr to a table of registered
                           ADD entry points
               'C' Set if error



          Remarks

          þ   ADD Entry Point Table format

           Note:  MAX DCTableEntries may be different for each Device Class
                  Device_Class = 1 (disk) has a maximum of 32 entries
                  Device_Class = 2 (mouse) has a maximum of 3 entries

                  struct DevClassTableEntry {
                          USHORT   DCOffset;
                          USHORT   DCSelector;
                          USHORT   DCFlags;
                          UCHAR    DCName[16];
                  };

                  struct DevClassTableStruc {
                     USHORT                     DCCount;
                     USHORT                     DCMaxCount;
                     struct DevClassTableEntry  DCTableEntries[MAX];
                  };








          
                               Appendix A: Device Manager - ADD Interface  65




          
          APPENDIX B: 'C' LANGUAGE DATA STRUCTURE DEFINITIONS


/*static char *SCCSID = "@(#)iorb.h     6.1 92/02/07";*/
/*static char *SCCSID = "@(#)iorb.h     6.4 92/01/16";*/
/**********************************************************************/
/* I/O Request Block (IORB) Structures                                */
/**********************************************************************/

/* ASM
;
;       Resolve H2INC references for .INC version of file
;
        include  iorbtype.inc
*/

/* Typedefs to resolve forward references */
typedef struct _IORBH         IORBH;
typedef struct _IORBH         FAR *PIORBH;
typedef struct _IORBH         *NPIORBH;
typedef struct _IORBH         FAR *PIORB;
typedef struct _IORBH         *NPIORB;

typedef struct _DEVICETABLE   DEVICETABLE;
typedef struct _DEVICETABLE   FAR *PDEVICETABLE;
typedef struct _DEVICETABLE   *NPDEVICETABLE;

typedef struct _UNITINFO      UNITINFO;
typedef struct _UNITINFO      FAR *PUNITINFO;
typedef struct _UNITINFO      *NPUNITINFO;

typedef struct _ADAPTERINFO   ADAPTERINFO;
typedef struct _ADAPTERINFO   FAR *PADAPTERINFO;
typedef struct _ADAPTERINFO   *NPADAPTERINFO;

typedef struct _GEOMETRY      GEOMETRY;
typedef struct _GEOMETRY      FAR *PGEOMETRY;
typedef struct _GEOMETRY      *NPGEOMETRY;

typedef struct _SCATGATENTRY  SCATGATENTRY;
typedef struct _SCATGATENTRY  FAR *PSCATGATENTRY;
typedef struct _SCATGATENTRY  *NPSCATGATENTRY;

/*-----------------------------------------*/
/* Interface for calling ADD entry point   */
/*-----------------------------------------*/
/* VOID FAR *(ADDEP) (PIORBH); */

/*-------------------------*/
/* IORB Header             */
/*-------------------------*/

#define DM_WORKSPACE_SIZE       20
#define ADD_WORKSPACE_SIZE      16


            Appendix B: 'C' Language Data Structure Definitions  66






typedef struct _IORBH   {               /* IOH */

  USHORT        Length;                 /* IORB Length                */
  USHORT        UnitHandle;             /* Unit Identifier            */
  USHORT        CommandCode;            /* Command Code               */
  USHORT        CommandModifier;        /* Command Modifier           */
  USHORT        RequestControl;         /* Request Control Flags      */
  USHORT        Status;                 /* Status                     */
  USHORT        ErrorCode;              /* Error Code                 */
  ULONG         Timeout;                /* Cmd completion timeout (s) */
  USHORT        StatusBlockLen;         /* Status block length        */
  NPBYTE        pStatusBlock;           /* Status block               */
  USHORT        Reserved_1;             /* Reserved, MBZ              */
  PIORB         pNxtIORB;               /* Pointer to next IORB       */
  PIORB         (FAR *NotifyAddress)(PIORB); /* Notification Address  */
  UCHAR         DMWorkSpace[DM_WORKSPACE_SIZE];   /* For use by DM    */
  UCHAR         ADDWorkSpace[ADD_WORKSPACE_SIZE]; /* For use by ADD   */

} IORBH;

/*---------------------------------------------------------------------*/
/* IORB CommandCode and CommandModifier Codes.                         */
/*      CommandCode prefixed by IOCC and CommandModifier by IOCM.      */
/*---------------------------------------------------------------------*/
                                          /*---------------------------*/
                                          /* +----M=Manditory Support  */
                                          /* |    O=Optional Support   */
                                          /* |                         */
                                          /* V     Notes               */
                                          /*---------------------------*/
#define IOCC_CONFIGURATION        0x0001  /*                           */
#define IOCM_GET_DEVICE_TABLE     0x0001  /* M                         */
#define IOCM_COMPLETE_INIT        0x0002  /* O                         */
                                          /*---------------------------*/
#define IOCC_UNIT_CONTROL         0x0002  /*                           */
#define IOCM_ALLOCATE_UNIT        0x0001  /* M                         */
#define IOCM_DEALLOCATE_UNIT      0x0002  /* M                         */
#define IOCM_CHANGE_UNITINFO      0x0003  /* M                         */
                                          /*---------------------------*/
#define IOCC_GEOMETRY             0x0003  /*                           */
#define IOCM_GET_MEDIA_GEOMETRY   0x0001  /* M                         */
#define IOCM_SET_MEDIA_GEOMETRY   0x0002  /* O (M) >1 Media type       */
#define IOCM_GET_DEVICE_GEOMETRY  0x0003  /* M                         */
#define IOCM_SET_LOGICAL_GEOMETRY 0x0004  /* O (M) CHS Addressable     */
                                          /*---------------------------*/
#define IOCC_EXECUTE_IO           0x0004  /*                           */
#define IOCM_READ                 0x0001  /* M                         */
#define IOCM_READ_VERIFY          0x0002  /* M                         */
#define IOCM_READ_PREFETCH        0x0003  /* O                         */
#define IOCM_WRITE                0x0004  /* M                         */
#define IOCM_WRITE_VERIFY         0x0005  /* M                         */
                                          /*---------------------------*/
#define IOCC_FORMAT               0x0005  /*                           */


            Appendix B: 'C' Language Data Structure Definitions  67





#define IOCM_FORMAT_MEDIA         0x0001  /* O (M) If HW requires      */
#define IOCM_FORMAT_TRACK         0x0002  /* O (M) If HW requires      */
#define IOCM_FORMAT_PROGRESS      0x0003  /* O                         */
                                          /*---------------------------*/
#define IOCC_UNIT_STATUS          0x0006  /*                           */
#define IOCM_GET_UNIT_STATUS      0x0001  /* M                         */
#define IOCM_GET_CHANGELINE_STATE 0x0002  /* M (O) Fixed Media Only    */
#define IOCM_GET_MEDIA_SENSE      0x0003  /* M                         */
                                          /*---------------------------*/
#define IOCC_DEVICE_CONTROL       0x0007  /*                           */
#define IOCM_ABORT                0x0001  /* O (M) SCSI                */
#define IOCM_RESET                0x0002  /* O (M) SCSI                */
#define IOCM_SUSPEND              0x0003  /* O (M) Floppy Driver       */
#define IOCM_RESUME               0x0004  /* O (M) Floppy Driver       */
#define IOCM_LOCK_MEDIA           0x0005  /* M (O) Fixed Media Only    */
#define IOCM_UNLOCK_MEDIA         0x0006  /* M (O) Fixed Media Only    */
                                          /*---------------------------*/
#define IOCC_ADAPTER_PASSTHRU     0x0008  /*                           */
#define IOCM_EXECUTE_SCB          0x0001  /* O                         */
#define IOCM_EXECUTE_CDB          0x0002  /* O (M) SCSI Adapters       */
                                          /*---------------------------*/

#define MAX_IOCC_COMMAND  IOCC_ADAPTER_PASSTHRU

/*--------------------------------------------------*/
/* Status flags returned in IORBH->Status           */
/*--------------------------------------------------*/
#define IORB_DONE                0x0001  /* 1=Done,  0=In progress     */
#define IORB_ERROR               0x0002  /* 1=Error, 0=No error        */
#define IORB_RECOV_ERROR         0x0004  /* Recovered error            */
#define IORB_STATUSBLOCK_AVAIL   0x0008  /* Status Block available     */

/*----------------------------------------------*/
/* Error Codes returned in IORBH->ErrorCode     */
/*----------------------------------------------*/

#define IOERR_RETRY                     0x8000

#define IOERR_CMD                       0x0100
#define IOERR_CMD_NOT_SUPPORTED         IOERR_CMD+1
#define IOERR_CMD_SYNTAX                IOERR_CMD+2
#define IOERR_CMD_SGLIST_BAD            IOERR_CMD+3
#define IOERR_CMD_SW_RESOURCE           IOERR_CMD+IOERR_RETRY+4
#define IOERR_CMD_ABORTED               IOERR_CMD+5
#define IOERR_CMD_ADD_SOFTWARE_FAILURE  IOERR_CMD+6
#define IOERR_CMD_OS_SOFTWARE_FAILURE   IOERR_CMD+7

#define IOERR_UNIT                      0x0200
#define IOERR_UNIT_NOT_ALLOCATED        IOERR_UNIT+1
#define IOERR_UNIT_ALLOCATED            IOERR_UNIT+2
#define IOERR_UNIT_NOT_READY            IOERR_UNIT+3
#define IOERR_UNIT_PWR_OFF              IOERR_UNIT+4

#define IOERR_RBA                       0x0300


            Appendix B: 'C' Language Data Structure Definitions  68





#define IOERR_RBA_ADDRESSING_ERROR      IOERR_RBA+IOERR_RETRY+1
#define IOERR_RBA_LIMIT                 IOERR_RBA+2
#define IOERR_RBA_CRC_ERROR             IOERR_RBA+IOERR_RETRY+3

#define IOERR_MEDIA                     0x0400
#define IOERR_MEDIA_NOT_FORMATTED       IOERR_MEDIA+1
#define IOERR_MEDIA_NOT_SUPPORTED       IOERR_MEDIA+2
#define IOERR_MEDIA_WRITE_PROTECT       IOERR_MEDIA+3
#define IOERR_MEDIA_CHANGED             IOERR_MEDIA+4
#define IOERR_MEDIA_NOT_PRESENT         IOERR_MEDIA+5

#define IOERR_ADAPTER                   0x0500
#define IOERR_ADAPTER_HOSTBUSCHECK      IOERR_ADAPTER+1
#define IOERR_ADAPTER_DEVICEBUSCHECK    IOERR_ADAPTER+IOERR_RETRY+2
#define IOERR_ADAPTER_OVERRUN           IOERR_ADAPTER+IOERR_RETRY+3
#define IOERR_ADAPTER_UNDERRUN          IOERR_ADAPTER+IOERR_RETRY+4
#define IOERR_ADAPTER_DIAGFAIL          IOERR_ADAPTER+5
#define IOERR_ADAPTER_TIMEOUT           IOERR_ADAPTER+IOERR_RETRY+6
#define IOERR_ADAPTER_DEVICE_TIMEOUT    IOERR_ADAPTER+IOERR_RETRY+7
#define IOERR_ADAPTER_REQ_NOT_SUPPORTED IOERR_ADAPTER+8
#define IOERR_ADAPTER_REFER_TO_STATUS   IOERR_ADAPTER+9
#define IOERR_ADAPTER_NONSPECIFIC       IOERR_ADAPTER+10


#define IOERR_DEVICE                    0x0600
#define IOERR_DEVICE_DEVICEBUSCHECK     IOERR_DEVICE+IOERR_RETRY+1
#define IOERR_DEVICE_REQ_NOT_SUPPORTED  IOERR_DEVICE+2
#define IOERR_DEVICE_DIAGFAIL           IOERR_DEVICE+3
#define IOERR_DEVICE_BUSY               IOERR_DEVICE+IOERR_RETRY+4
#define IOERR_DEVICE_OVERRUN            IOERR_DEVICE+IOERR_RETRY+5
#define IOERR_DEVICE_UNDERRUN           IOERR_DEVICE+IOERR_RETRY+6
#define IOERR_DEVICE_RESET              IOERR_DEVICE+7
#define IOERR_DEVICE_NONSPECIFIC        IOERR_DEVICE+8



/*---------------------------------------------------*/
/* Request Control flags in IORBH->RequestControl    */
/*---------------------------------------------------*/

#define  IORB_ASYNC_POST        0x0001   /* Asynchronous post enabled  */
#define  IORB_CHAIN             0x0002   /* IORB Chain Link enabled    */
#define  IORB_CHS_ADDRESSING    0x0004   /* CHS fmt addr in RBA Field  */
#define  IORB_REQ_STATUSBLOCK   0x0008   /* Obtain Status Block Data   */
#define  IORB_DISABLE_RETRY     0x0010   /* Disable retries in ADD     */


/***********************************************************************/
/* ADAPTER CONFIGURNATION IORB         (for IOCC_CONFIGURATION)        */
/***********************************************************************/
typedef struct _IORB_CONFIGURATION   {  /* IOCFG */

  IORBH            iorbh;               /* IORB Header                  */
  DEVICETABLE far *pDeviceTable;        /* far ptr to adapter dev table */


            Appendix B: 'C' Language Data Structure Definitions  69





  USHORT           DeviceTableLen;      /* Length of adapter dev table  */

} IORB_CONFIGURATION, FAR *PIORB_CONFIGURATION, *NPIORB_CONFIGURATION;

/* Adapter device table returned by GET_DEVICE_TABLE                      */
typedef struct _DEVICETABLE  {            /* IODT */

  UCHAR         ADDLevelMajor;            /* ADD Major Support Level       */
  UCHAR         ADDLevelMinor;            /* ADD Minor Support Level       */
  USHORT        ADDHandle;                /* ADD Handle                    */
  USHORT        TotalAdapters;            /* Number of adapters supported  */
  NPADAPTERINFO pAdapter[1];              /* Array of adapter info pointers*/

} DEVICETABLE, FAR *PDEVICETABLE;

/*-----------------------------------------------------------------*/
/* Current ADD Level for DEVICETABLE->AddLevelMajor, AddLevelMinor */
/*-----------------------------------------------------------------*/

#define ADD_LEVEL_MAJOR         0x01
#define ADD_LEVEL_MINOR         0x00


typedef struct _UNITINFO   {           /* IOUI */

  USHORT    AdapterIndex;              /* nth Adapter this driver     */
  USHORT    UnitIndex;                 /* nth Unit on this card       */
  USHORT    UnitFlags;                 /* Unit Flags                  */
  USHORT    Reserved;                  /* Reserved                    */
  USHORT    UnitHandle;                /* Assigned by ADD or Filter   */
  USHORT    FilterADDHandle;           /* Handle of Filter ADD  0=None*/
  USHORT    UnitType;                  /* Unit type                   */
  USHORT    QueuingCount;              /* Recommended number to queue */
  UCHAR     UnitSCSITargetID;          /* SCSI Target ID  (SCSI Only) */
  UCHAR     UnitSCSILUN;               /* SCSI Log.  Unit (SCSI Only) */

} UNITINFO;


/*------------------------------------------*/
/* Unit Flags for UNITINFO->UnitFlags       */
/*------------------------------------------*/

#define UF_REMOVABLE     0x0001         /* Media can be removed            */
#define UF_CHANGELINE    0x0002         /* ChangeLine Supported            */
#define UF_PREFETCH      0x0004         /* Supports prefetch reads         */
#define UF_A_DRIVE       0x0008         /* Manages A:                      */
#define UF_B_DRIVE       0x0010         /* Manages B:                      */
#define UF_NODASD_SUPT   0x0020         /* Suppress DASD Mgr support       */
#define UF_NOSCSI_SUPT   0x0040         /* Suppress SCSI Mgr support       */
#define UF_DEFECTIVE     0x0080         /* Device is defective             */


/*------------------------------------------*/


            Appendix B: 'C' Language Data Structure Definitions  70





/* Unit Types for UNITINFO->UnitType        */
/*------------------------------------------*/

#define  UIB_TYPE_DISK      0x0000     /* All Direct Access Devices        */
#define  UIB_TYPE_TAPE      0x0001     /* Sequencial Access Devices        */
#define  UIB_TYPE_PRINTER   0x0002     /* Printer Device                   */
#define  UIB_TYPE_PROCESSOR 0x0003     /* Processor type device            */
#define  UIB_TYPE_WORM      0x0004     /* Write Once Read Many Device      */
#define  UIB_TYPE_CDROM     0x0005     /* CD ROM Device                    */
#define  UIB_TYPE_SCANNER   0x0006     /* Scanner Device                   */
#define  UIB_TYPE_OPTICAL_MEMORY 0x0007 /* some Optical disk               */
#define  UIB_TYPE_CHANGER   0x0008     /* Changer device e.g. juke box     */
#define  UIB_TYPE_COMM      0x0009     /* Communication devices            */


typedef struct _ADAPTERINFO   {           /* IOAI */

  UCHAR            AdapterName[17];       /* Adapter Name ASCIIZ string    */
  UCHAR            Reserved;              /*                               */
  USHORT           AdapterUnits;          /* Number of units this adapter  */
  USHORT           AdapterDevBus;         /* Bus Type - Adapter to Device  */
  UCHAR            AdapterIOAccess;       /* I/O Type - Adapter to Host    */
  UCHAR            AdapterHostBus;        /* Bus Type - Adapter to Host    */
  UCHAR            AdapterSCSITargetID;   /* Adapter SCSI Target ID        */
  UCHAR            AdapterSCSILUN;        /* Adapter SCSI LUN              */
  USHORT           AdapterFlags;
  USHORT           MaxHWSGList;           /* Max HW S/G List Entries       */
  ULONG            MaxCDBTransferLength;  /* Max data length for CDBs      */
  UNITINFO         UnitInfo[1];           /* Unit info for each unit       */

} ADAPTERINFO;


/*---------------------------------------------------*/
/* Adapter Flags for ADAPTERINFO->AdapterFlags       */
/*---------------------------------------------------*/

#define AF_16M            0x0001         /* Supports >16M addresses        */
#define AF_IBM_SCB        0x0002         /* Supports IBM SCB commands      */
#define AF_HW_SCATGAT     0x0004         /* Supports scatter/gather in HW  */
#define AF_CHS_ADDRESSING 0x0008         /* Supports CHS addressing in HW  */


/*-----------------------------------------------------------------*/
/* Adapter-to-Device protocol for ADAPTERINFO->AdapterDevBus       */
/*-----------------------------------------------------------------*/

#define  AI_DEVBUS_OTHER        0x0000
#define  AI_DEVBUS_ST506        0x0001 /* ST-506 CAM-I                     */
#define  AI_DEVBUS_ST506_II     0x0002 /* ST-506 CAM-II                    */
#define  AI_DEVBUS_ESDI         0x0003 /* ESDI                             */
#define  AI_DEVBUS_FLOPPY       0x0004 /* Diskette                         */
#define  AI_DEVBUS_SCSI_1       0x0005
#define  AI_DEVBUS_SCSI_2       0x0006


            Appendix B: 'C' Language Data Structure Definitions  71





#define  AI_DEVBUS_SCSI_3       0x0007

/*-------------------------------------------------------------*/
/* Note: A one of the following BUS WIDTH indicators should be */
/*       or'd with the above field.                            */
/*-------------------------------------------------------------*/

#define  AI_DEVBUS_FAST_SCSI    0x0100
#define  AI_DEVBUS_8BIT         0x0200
#define  AI_DEVBUS_16BIT        0x0400
#define  AI_DEVBUS_32BIT        0x0800


/*-----------------------------------------------------------------*/
/* Adapter-to-Device protocol for ADAPTERINFO->AdapterIOAccess     */
/*-----------------------------------------------------------------*/

#define  AI_IOACCESS_OTHER      0x00
#define  AI_IOACCESS_BUS_MASTER 0x01
#define  AI_IOACCESS_PIO        0x02
#define  AI_IOACCESS_DMA_SLAVE  0x04
#define  AI_IOACCESS_MEMORY_MAP 0x08


/*-----------------------------------------------------------------*/
/* Adapter-to-Host bus type for ADAPTERINFO->AdapterHostBus        */
/*-----------------------------------------------------------------*/

#define  AI_HOSTBUS_OTHER       0x00
#define  AI_HOSTBUS_ISA         0x01
#define  AI_HOSTBUS_EISA        0x02
#define  AI_HOSTBUS_uCHNL       0x03
#define  AI_HOSTBUS_UNKNOWN     0x0f

/*-------------------------------------------------------------*/
/* Note: A one of the following BUS WIDTH indicators should be */
/*       or'd with the above field.                            */
/*-------------------------------------------------------------*/

#define  AI_BUSWIDTH_8BIT       0x10
#define  AI_BUSWIDTH_16BIT      0x20
#define  AI_BUSWIDTH_32BIT      0x30
#define  AI_BUSWIDTH_64BIT      0x40
#define  AI_BUSWIDTH_UNKNOWN    0xf0


/***********************************************************************/
/* UNIT CONTROL IORB                  (for IOCC_UNIT_CONTROL)          */
/***********************************************************************/

typedef struct _IORB_UNIT_CONTROL  {     /* IOUC */

  IORBH            iorbh;                /* IORB Header                  */
  USHORT           Flags;                /*                              */


            Appendix B: 'C' Language Data Structure Definitions  72





  PUNITINFO        pUnitInfo;            /* For: IOCM_CHANGE_UNITINFO    */
  USHORT           UnitInfoLen;          /* Length of UnitInfo structure */

} IORB_UNIT_CONTROL, FAR *PIORB_UNIT_CONTROL, *NPIORB_UNIT_CONTROL;

/***********************************************************************/
/* DASD GEOMETRY IORB                      (for IOCC_GEOMETRY)         */
/***********************************************************************/

typedef struct _IORB_GEOMETRY  {         /* IOGG */

  IORBH            iorbh;                /* IORB Header                  */
  PGEOMETRY        pGeometry;            /* far ptr to GEOMETRY block    */
  USHORT           GeometryLen;          /* Length of GEOMETRY block     */

} IORB_GEOMETRY, FAR *PIORB_GEOMETRY, *NPIORB_GEOMETRY;

typedef struct _GEOMETRY  {              /* IOG */

  ULONG    TotalSectors;
  USHORT   BytesPerSector;
  USHORT   Reserved;
  USHORT   NumHeads;
  ULONG    TotalCylinders;
  USHORT   SectorsPerTrack;

} GEOMETRY, FAR *PGEOMETRY, *NPGEOMETRY;



/*****************************/
/* Scatter/Gather List Entry */
/*****************************/

typedef struct _SCATGATENTRY  {      /* IOSG */

  ULONG         ppXferBuf;           /* Physical pointer to transfer buffer */
  ULONG         XferBufLen;          /* Length of transfer buffer           */

} SCATGATENTRY, FAR *PSCATGATENTRY, *NPSCATGATENTRY;

#define MAXSGLISTSIZE   (sizeof(SCATGATENTRY)) * 16

/***********************************************************************/
/* EXECUTE_IO IORB                    (for IOCC_EXECUTE_IO)            */
/***********************************************************************/

typedef struct _IORB_EXECUTEIO  {            /* IOXIO */

  IORBH         iorbh;                       /* IORB Header                */
  USHORT        cSGList;                     /* Count of S/G list elements */
  PSCATGATENTRY pSGList;                     /* far ptr to S/G List        */
  ULONG         ppSGList;                    /* physical addr of  S/G List */
  ULONG         RBA;                         /* RBA Starting Address       */


            Appendix B: 'C' Language Data Structure Definitions  73





  USHORT        BlockCount;                  /* Block Count                */
  USHORT        BlocksXferred;               /* Block Done Count           */
  USHORT        BlockSize;                   /* Size of a block in bytes   */
  USHORT        Flags;

} IORB_EXECUTEIO, FAR *PIORB_EXECUTEIO, *NPIORB_EXECUTEIO;


/**********************************************/
/* CHS Direct Addressing (Overlays RBA field) */
/**********************************************/

typedef struct _CHS_ADDR  {                  /* IOCHS */

  USHORT        Cylinder;
  UCHAR         Head;
  UCHAR         Sector;

} CHS_ADDR, FAR *PCHS_ADDR, *NPCHS_ADDR;


/*------------------------------------------------*/
/* IORB specific flags for IORB_EXECUTE_IO->Flags */
/*------------------------------------------------*/

#define  XIO_DISABLE_HW_WRITE_CACHE      0x0001
#define  XIO_DISABLE_HW_READ_CACHE       0x0002


/***********************************************************************/
/* FORMAT IORB                        (for IOCC_FORMAT)                */
/***********************************************************************/


typedef struct _IORB_FORMAT  {               /* IOFMT */

  IORBH         iorbh;                       /* IORB Header                */
  USHORT        cSGList;                     /* Count of S/G list elements */
  PSCATGATENTRY pSGList;                     /* far ptr to S/G List        */
  ULONG         ppSGList;                    /* physical addr of  S/G List */
  USHORT        FormatCmdLen;                /*                            */
  PBYTE         pFormatCmd;                  /* SCSI CDB or Track Fmt Cmd  */
  UCHAR         Reserved_1[8];               /* Reserved, must not be modified*/

} IORB_FORMAT, FAR *PIORB_FORMAT, *NPIORB_FORMAT;


typedef struct _FORMAT_CMD_TRACK {           /* FMCT  */

  USHORT        Flags;
  ULONG         RBA;
  USHORT        cTrackEntries;

} FORMAT_CMD_TRACK, FAR *PFORMAT_CMD_TRACK, *NPFORMAT_CMD_TRACK;


            Appendix B: 'C' Language Data Structure Definitions  74







/*--------------------------------------*/
/* Flags for FORMAT_CMD_TRACK->Flags    */
/*--------------------------------------*/

#define FF_VERIFY       0x0001          /* Verify sectors after formatting */


/***********************************************************************/
/* ADAPTER PASS THROUGH IORB           (for IOCC_ADAPTER_PASSTHRU)     */
/***********************************************************************/

typedef struct _IORB_ADAPTER_PASSTHRU  {  /* IOPT */

  IORBH         iorbh;                       /* IORB Header                */
  USHORT        cSGList;                     /* Count of S/G list elements */
  PSCATGATENTRY pSGList;                     /* far ptr to S/G List        */
  ULONG         ppSGLIST;                    /* physical addr of  S/G List */
  USHORT        ControllerCmdLen;
  PBYTE         pControllerCmd;
  ULONG         ppSCB;              /* phys ptr to SCB for SCB_PASSTHRU    */
  USHORT        Flags;

} IORB_ADAPTER_PASSTHRU, FAR *PIORB_ADAPTER_PASSTHRU, *NPIORB_ADAPTER_PASSTHRU;

/*------------------------------------------------------*/
/* IORB specific flags for IORB_ADAPTER_PASSTHRU->Flags */
/*                                                      */
/* Note: These flags apply to IOCM_EXECUTE_CDB          */
/*------------------------------------------------------*/

#define PT_DIRECTION_IN     0x0001           /* Data xfer to host adapter  */


/***********************************************************************/
/* UNIT STATUS IORB                   (for IOCC_UNIT_STATUS)           */
/***********************************************************************/

typedef struct _IORB_UNIT_STATUS  {        /* IOUS */

  IORBH      iorbh;
  USHORT     UnitStatus;

} IORB_UNIT_STATUS, FAR *PIORB_UNIT_STATUS, *NPIORB_UNIT_STATUS;


/*------------------------------------------------------*/
/* Unit Status for IORB_UNIT_STATUS->UnitStatus         */
/*                                                      */
/* Note: These flags apply to IOCM_GET_UNIT_STATUS      */
/*------------------------------------------------------*/

#define US_READY                0x0001          /* Unit ready          */


            Appendix B: 'C' Language Data Structure Definitions  75





#define US_POWER                0x0002          /* Unit powered on     */
#define US_DEFECTIVE            0x0004          /* Unit operational    */


/*------------------------------------------------------*/
/* Unit Status for IORB_UNIT_STATUS->UnitStatus         */
/*                                                      */
/* Note: These flags apply to IOCM_GET_CHANGELINE_STATE */
/*------------------------------------------------------*/

#define US_CHANGELINE_ACTIVE    0x0001          /* ChangeLine State    */


/*------------------------------------------------------*/
/* Unit Status for IORB_UNIT_STATUS->UnitStatus         */
/*                                                      */
/* Note: These flags apply to IOCM_GET_MEDIA_SENSE      */
/*------------------------------------------------------*/

#define US_MEDIA_UNKNOWN        0x0000          /* Unable to determine media */
#define US_MEDIA_720KB          0x0001          /* 720KB in 3.5" drive       */
#define US_MEDIA_144MB          0x0002          /* 1.44MB in 3.5" drive      */
#define US_MEDIA_288MB          0x0003          /* 2.88MB in 3.5" drive      */


/***********************************************************************/
/* DEVICE CONTROL IORB                (for IOCC_DEVICE_CONTROL         */
/***********************************************************************/


typedef struct _IORB_DEVICE_CONTROL   {   /* IODC */

  IORBH      iorbh;                       /* IORB Header                */
  USHORT     Flags;
  USHORT     Reserved;

} IORB_DEVICE_CONTROL, FAR *PIORB_DEVICE_CONTROL, *NPIORB_DEVICE_CONTROL;


/*------------------------------------------------------*/
/* IORB specific flags for IORB_DEVICE_CONTROL->Flags   */
/*                                                      */
/* Note: These flags apply to IOCM_SUSPEND              */
/*------------------------------------------------------*/

#define DC_SUSPEND_DEFERRED     0x0000          /* Suspend after device idle */
#define DC_SUSPEND_IMMEDIATE    0x0001          /* Suspend after current req */


#define MAX_IORB_SIZE   128





          
                      Appendix B: 'C' Language Data Structure Definitions  76




          
          APPENDIX C: SUMMARY OF ERROR HANDLING






















































          
                                    Appendix C: Summary of Error Handling  77




          
          APPENDIX D: ERROR MANAGEMENT

          In order to  facilitate the use of device managers across a variety
          of  ADDs,  this specification defines  a set  of error codes  which
          should be supplied in the ErrorCode field of the  IORB in the event
          of a failed operation. The responsibility for translation of device
          error data into these error codes rests with the ADD.

          The following guidelines should be helpful:

          1.  In general an ADD should not be programmed  'defensively', i.e.
              it should consider the device manager a 'trusted' component and
              should  not  implement excessive  safeguards. However, the  ADD
              must  protect itself against commands  outside its  implemented
              command set to allow upward compatibility.

          2.  In general an ADD should be programmed 'defensively' concerning
              the devices it manages, i.e. it should  protect  against itself
              against timeouts and hung devices, and  transient environmental
              factors, noise, etc...

          3.  The  OS/2  DASD  Manager requires  translation of  device error
              information  into the error codes listed  in  the  "Summary  of
              Error Codes" Appendix.  The  DASD Manager expects  errors to be
              fully processed by the ADD. In particular, using the error code
              IOERR_ADAPTER_REFER_TO_STATUS   will  not  result  in   correct
              operation.

          4.  For other  Device  Managers,  it  is  recommended that the same
              error analysis be done. If this error analysis does not produce
              a      reliable      error       indication,      then      the
              IOERR_ADAPTER_REFER_TO_STATUS code may be used.

          5.  An  IOERR_RETRY  flag is included  on commands which  should be
              retried by the  ADD. This flag  is ignored by  Device  Managers
              since retries should be performed at the ADD level. In addition
              this  flag should be ignored if  the device manager has set the
              IORB_DISABLE_RETRY bit in the IORB.

          6.  Certain commands  are  not expected to fail  regardless of  the
              condition of the underlying devices. Specifically:

                  IOCM_GET_UNIT_STATUS

          7.  Certain command address the entire  ADD rather than  a specific
              unit. This case  ALLOCATION  checks should  not  be  performed.
              Specifically:

                  IOCM_GET_DEVICE_TABLE






          
                                             Appendix D: Error Management  78




          
          APPENDIX E: SUMMARY OF ERROR CODES

          This  appendix  describes  all  the ADD error  codes.  On  abnormal
          termination of a direct call command, the ADD sets the IORBH Status
          field -  IORB_ERROR flag and the  IORBH ErrorCode field with one of
          the error codes listed below.  The error codes are grouped by error
          category.  Where stated, the ADD is required to retry the function,
          prior to returning the error code to the caller.

          þ   IOERR_CMD

              This error category maps errors related to  the IORB command an
              ADD receives.

              IOERR_CMD_NOT_SUPPORTED

                   This error indicates  that the ADD has not implemented the
                   requested function. This includes  commands  the  ADD does
                   not 'understand'.


              IOERR_CMD_SYNTAX

                   This   error  indicates  that  the  ADD  has  detected  an
                   inconsistency  in  the  IORB   which  prevents  successful
                   execution of the requested function.


              IOERR_CMD_SGLIST_BAD

                   This  error  indicates  that  the  ADD  cannot  accept the
                   Scatter/Gather list passed.  This may  be due either to an
                   defect in the Scatter/Gather list (zero  length  segment),
                   or the inability of the adapter to accept  the list due to
                   an underlying hardware limitation.

              IOERR_CMD_SW_RESOURCE (retry required)

                   This error indicates that the ADD could  not  perform  the
                   requested function due to the lack of a software resource,
                   i.e. buffer, selector, etc.. It should be  noted  that the
                   ADD  should   attempt  to  recover  from  this  condition,
                   (attempt to use a smaller  buffer, etc.)  even if degraded
                   performance results.


              IOERR_CMD_ABORTED

                   This error is returned when an IOCM_ABORT is  received for
                   a device which  is currently  processing a  command.  This
                   error code should be  set regardless of  SCSI 'Sense Data'
                   which may indicate a successful command completion.



          
                                       Appendix E: Summary of Error Codes  79




          
          þ   IOERR_UNIT

              This error category  maps errors related to the condition of an
              addressed unit.

              IOERR_UNIT_NOT_ALLOCATED

                   This error indicates that the  unit  has  received an IORB
                   command  prior  to being allocated.  This error should  be
                   returned to all  commands directed to  a unit  prior to it
                   receiving an IOCM_ALLOCATE_UNIT command.


              IOERR_UNIT_ALLOCATED

                   This error  indicates an  attempt was  made  to allocate a
                   unit which had been previous  allocated. It would normally
                   only  be returned  in  response to IOCM_ALLOCATE_UNIT when
                   another ALLOCATE is outstanding.


              IOERR_UNIT_NOT_READY

                   This  error indicates  that a unit is unable to an perform
                   an otherwise  valid operation. This  is usually due to  an
                   unusual condition on a  unit,  such  as  incorrect spindle
                   speed.  Note, the ADD should not return this error  as the
                   result of normal start-up delays on devices.


              IOERR_UNIT_PWR_OFF

                   The ADD may  optionally return this error if it has access
                   to  back-up configuration data (CMOS) which would indicate
                   that a previously configured device  is  not available. If
                   back-up  configuration  data  is  not  available,  then  a
                   powered-off unit would  not  normally appear  it the ADD's
                   DEVICETABLE,  and  this  error  condition  would   not  be
                   possible.
















          
                                       Appendix E: Summary of Error Codes  80




          
          þ   IOERR_RBA

              This error category  refers  to  problems accessing a  relative
              block address (RBA) on a particular unit.

              IOERR_RBA_ADDRESSING_ERROR (retry required)

                   This  error indicates that the requested RBA could  not be
                   located.  This  may  be due  to  a  failure  to  find  the
                   appropriate address marks on a particular device.


              IOERR_RBA_LIMIT

                   This  error indicates that the RBA  indicated exceeded the
                   maximum  allowable  RBA for the  media  currently  in  the
                   device.


              IOERR_RBA_CRC_ERROR (retry required)

                   This error  indicates that the RBA was found, however, the
                   data requested could not be read successfully.
































          
                                       Appendix E: Summary of Error Codes  81




          
          þ   IOERR_MEDIA

              This error category refer to problems relating to  the media in
              a drive.

              IOERR_MEDIA_NOT_FORMATTED

                   This error indicates that the  requested  operation  could
                   not  be  performed  since the  media in the drive requires
                   low-level formatting to be usable. This  includes requests
                   to determine the media capacity (IOCM_GET_MEDIA_GEOMETRY),
                   if such requests require formatted media.


              IOERR_MEDIA_NOT_SUPPORTED

                   This error indicates that  the  drive detected media which
                   it  is not  capable of supporting.  If  the ADD or  device
                   cannot make this determination directly, then an I/O error
                   may be may be returned in lieu of this error.


              IOERR_MEDIA_WRITE_PROTECT

                   This error indicates that either the media or the drive is
                   write protected, or that the media is not writable.


              IOERR_MEDIA_CHANGED

                   This error indicates that the media in the drive may  have
                   been changed, i.e. a removal  and  insertion of the  media
                   has been detected since the last operation on the device.


              IOERR_MEDIA_NOT_PRESENT

                   This error indicates that the operation requested requires
                   media  to be present  in the drive and  failed  due to the
                   fact that media was not in the drive.















          
                                       Appendix E: Summary of Error Codes  82




          
          þ   IOERR_ADAPTER

              This  error  category refers to errors  which are related to or
              detected by the host adapter.

              IOERR_ADAPTER_HOSTBUSCHECK

                   This error  refers to  problems with the adapter's ability
                   to  communicate with the  host CPU.  These  error  include
                   incorrect  parity  on  data   received   from   the  host.
                   Frequently these error  are of  a severe  enough nature to
                   cause shutdown of the  host system. In these cases  normal
                   host bus  management  procedures  take precedence over the
                   reporting of this error.


              IOERR_ADAPTER_DEVICEBUSCHECK (retry required)

                   This error  refers to  problems with the adapter's ability
                   to  communicate  with  an  attached  device.  These errors
                   include  incorrect  parity  on  data  received  from   the
                   attached  device  or  incorrect  bus  protocols. Normally,
                   these errors are recoverable and should be retried.


              IOERR_ADAPTER_OVERRUN (retry required)

                   This error either indicates that the host adapter has lost
                   data from a device  due to its buffers being filled faster
                   than they can be emptied by the host CPU, or that a device
                   attempted  to  supply more data  than was  expected by the
                   host adapter.


              IOERR_ADAPTER_UNDERRUN (retry required)

                   This error  either indicates that  the  host  adapter  was
                   unable to supply  data on demand to a  device which caused
                   the device's  operation to fail or  a device was expecting
                   more data than the adapter was programmed to supply.


              IOERR_ADAPTER_DIAGFAIL

                   This error indicates that  the  host  adapter  detected an
                   internal consistency check  which  prevents  its continued
                   operation.  The ADD  may  or  may not choose to retry  the
                   requested operation based on the severity of the error.







          
                                       Appendix E: Summary of Error Codes  83




          
              IOERR_ADAPTER_TIMEOUT (retry required)

                   This error indicates that the ADD's timeout for an adapter
                   to  respond  has  been exceeded. Normally, the  ADD  would
                   initiate a retry sequence if this error occurs.

              IOERR_ADAPTER_DEVICE_TIMEOUT (retry required)

                   This error indicate the failure to a device  to respond to
                   the host adapter.


              IOERR_ADAPTER_REQ_NOT_SUPPORTED

                   The requested operation  or  function is  not supported by
                   this adapter.


              IOERR_ADAPTER_REFER_TO_STATUS (retry required)

                   The  reported  error  could not be  classified. Additional
                   information may  be  provided in the  IORB  StatusBlock if
                   requested by the Device Manager.  The ADD should retry the
                   operation as indicated by the IORB_DISABLE_RETRY bit.































          
                                       Appendix E: Summary of Error Codes  84




          
          þ   IOERR_DEVICE

              This error  category relates to errors detected by and relating
              to devices connected to a host adapter.

              IOERR_DEVICE_DEVICEBUSCHECK (retry required)

                   This error refers to a problem in communications between a
                   host adapter and device which was detected  by the device.
                   This would  include  incorrect  parity on data received by
                   the host adapter or a breakdown in bus  protocols  between
                   the device and host adapter.


              IOERR_DEVICE_REQ_NOT_SUPPORTED

                   The requested operation  or function is not  supported  by
                   this device.


              IOERR_DEVICE_DIAGFAIL (retry required)

                   This error indicates that the  device detected an internal
                   consistency check  which prevents its  correct  operation.
                   Depending on the severity of the problem  the ADD  may  or
                   may not choose retry the operation.


              IOERR_DEVICE_BUSY (retry required)

                   The  device  is  busy  and  cannot  accept  the  requested
                   operation. This  includes  but  is  not  limited  to  SCSI
                   'Contingent Allegiance' conditions.


              IOERR_DEVICE_OVERRUN (retry required)

                   This error either indicates that the device has lost  data
                   due  to  its buffers being filled faster than they can  be
                   emptied by  the host adapter, or that the device attempted
                   to supply more data than the host adapter would accept.


              IOERR_DEVICE_UNDERRUN (retry required)

                   This error either indicates that  the device was unable to
                   obtain data on demand which  caused the device's operation
                   to fail, or a device operation required more data than was
                   supplied by the host adapter.






          
                                       Appendix E: Summary of Error Codes  85




          
              IOERR_DEVICE_RESET

                   This  error  either  indicates  that the  device was reset
                   which caused the device's operation to fail.



















































          
                                       Appendix E: Summary of Error Codes  86




          
          APPENDIX F: LIBRARY ROUTINES



          A complement of library  services for  common ADD tasks is provided
          with the  ADD development toolkit.  The library provides  a set  of
          functions which are statically linked with the ADD at link time.

          These services include:

          þ   'C' interface to the DevHelp kernel services

          þ   timer services

          þ   scatter/gather buffer transfers

          þ   command line parsing

          þ   RBA <-> CHS computations

          þ   DMA setup and channel control, ISA bus machines


































          
                                             Appendix F: Library Routines  87




          
          APPENDIX G: OS/2 1.3 COMPATIBILITY

          In order to  maintain  the extensive development of  many adapters,
          devices  and  option  manufactures,  OS/2  2.0  generally  provides
          compatibility with OS/2 1.3 device drivers.

          Compatibility  is  provided for OS/2 1.3 device drivers written  to
          either  the  published  OS/2 1.3  device  driver  interface  or  in
          accordance  with  the LADDR  architecture.  IBM  does not, however,
          distribute any component of  the LADDR  configuration;  all  TSD's,
          VSD's, BID's, and IOS components must be sourced outside of IBM.

          There are a small  number of compatibly problem areas  between OS/2
          versions 1.x  and 2.0.  For a  complete  list,  reference  the OS/2
          Version  2.0  toolkit  publications;   highlights  are   summarized
          briefly here:

          þ   Device drivers that  directly modify or utilize the contents of
              the  Global Descriptor  Table  (GDT)  or Local Descriptor Table
              (LDT) are not supported.

          þ   The PhysToUVirt DevHelp behaves somewhat differently in certain
              usage scenarios.

          þ   Device drivers  that set up  their  own  GDT call gate will not
              work.

          þ   Device drivers that switch to real mode will fail.

          In  addition,  due  to  the architectural differences  between  the
          16-bit and 32-bit releases of OS/2, existing device drivers may not
          maintain   their   current    performance    characteristics.   The
          architectural differences are characterized as follows:

          þ   Paging versus Segment Swapping

              OS/2 2.0 provides  virtual memory management through the use of
              the demand paging architecture of the 32-bit modes of the INTEL
              386  and  above processors.  OS/2  1.3  provides virtual memory
              management through the use of segment swapping as  supported by
              the INTEL 286 processor.  Due to  this difference, I/O requests
              are no longer  guaranteed to  take  place in single  physically
              contiguous  memory  address range.  In  order  to  provide  for
              compatibility, when OS/2 File Systems detect an OS/2 1.3 device
              driver, the application's I/O requests are broken into multiple
              I/O  requests   to  the  device  driver   at  physical   memory
              boundaries. Depending  on  the  degree of fragmentation of  the
              application  buffer the device driver  may  see  from  1 to  17
              separate requests for what was once a  single I/O  operation in
              OS/2 1.3.

              This  introduces   performance  degradation  for  DASD  devices
              without  read-ahead  hardware  caching,  since   these  devices
              generally incur a rotational overhead on a per request basis.

          
                                       Appendix G: OS/2 1.3 Compatibility  88




          
          þ   Support for More Than 16 Megabytes of Memory

              OS/2 provides support  for  more than  16 megabytes of physical
              memory to be installed in the computer that it is operating on.
              OS/2  1.2 and many adapters and  devices only provided  support
              for 16  megabytes of physical memory.  In  order to provide for
              compatibility, when an existing  device driver utilizes an OS/2
              1.3 compatible request  to lock memory for  DMA transfers, OS/2
              2.0  rearranges memory  so  that all of the  requested physical
              memory address range is below the 16 megabyte limit.













































          
                                       Appendix G: OS/2 1.3 Compatibility  89




          
          APPENDIX H: GLOSSARY


          Adapter Device Driver (ADD) An  OS/2 device  driver written to this
          specification.  Adapter  device  drivers  provide  either  hardware
          dependent  services for  an  OEM  adapter  or  contain  value-added
          subsystems such as encryption, or data striping.

          Bus Master Adapter An adapter capable of performing reads/writes to
          physical  storage  by  directly  communicating  with  the   storage
          subsystem (memory) rather than depending on a  host  DMA channel or
          host CPU. Also referred to as a "First-Party DMA adapter".

          Device Driver A   module    written   to    OS/2    device   driver
          specifications.  See  "OS/2  Programming  Tools and  Information  -
          Version 2.0".

          Command The  term 'Command' in this specification refers to a group
          of related  commands an  Adapter  Device  Driver  may  receive  For
          example, common  I/O requests (read,  write, etc) are grouped under
          the command EXECUTE_IO.

          Command Modifier The  term  'Command Modifier' refers to a specific
          operation that an Adapter Device Driver is to perform. For example,
          an  Adapter Device Driver may receive  an EXECUTE_IO command with a
          command modifier of READ.

          Command Data Block A  data  structure defined by the Small Computer
          System Interface (SCSI)  to send commands to devices  conforming to
          SCSI standards. See SCSI.

          Device Table A  device  table  is  a data  structure  containing  a
          summary  of the  adapters an Adapter  Device Driver supports and  a
          list of  the  I/O  device  attached  to  each  adapter.  This  data
          structure is  built by the Adapter  Device Driver  in response to a
          DEVICE_CONFIGURATION/BUILD_DEVICE_TABLE request.

          Device Helper (DevHlp) Device Helpers are a set of  C  or assembler
          callable routines which  provide operating system services for OS/2
          Device Drivers.

          DASD Geometry DASD  Geometry  is  a data  structure  which  returns
          information relating to the organization of  direct access devices.
          It contains  the Cylinder/Head/Sector  layout  of a device, the RBA
          capacity of the device and the block size of the device.

          DMA Slave An adapter which requires a host  DMA channel to  perform
          data  transfers on its  behalf. Also referred to as a "Second-Party
          DMA Adapter".

          Flat Address
           See Linear Address.

          Initialization (Init) Time After  OS/2  loads  device  drivers,  it

          
                                                     Appendix H: Glossary  90




          
          sends  them  an  OS/2  Request  Packet  to initialize.  During this
          initialization  certain Device Help  functions  are  not permitted.
          Refer  to  this  specification  and  "OS/2  Programming  Tools  and
          Information - Version 2.0" for further information on device driver
          initialization.

          Interrupt Time OS/2  Device Drivers receive  interrupts either from
          the hardware they manage or from the system real-time clock. When a
          device  driver  is  run  due  to  an   interrupt  (rather  than  an
          application request) it is said to be running at 'Interrupt  Time'.
          During  interrupt  time,  certain  Device  Help  function  are  not
          permitted.   Also,   addresses   received   directly   from    OS/2
          applications  may not be valid unless converted 'system addresses'.
          Refer  to  this  specification  and  "OS/2  Programming  Tools  and
          Information - Version 2.0" for further information on device driver
          interrupt time processing.

          I/O Request Block (IORB) The  I/O request block is a data structure
          defined by this specification  which is passed as a parameter to on
          all calls to an Adapter Device Driver. It contains  a fixed section
          followed  by  a   command   dependent   section.   Refer   to  this
          specification for the definition the IORB data structure.

          Linear Address A 32-Bit byte address for a piece data  which may or
          may  not  have  been  assigned to physical storage.  The  host  CPU
          automatically translates linear addresses to physical addresses and
          raises  an  exception  if  OS/2  must  assign physical storage to a
          linear address which has been referenced.

          OS2DASD.SYS This  is  an  OS/2  device driver  provided  by  IBM to
          communicate  with  Adapter   Device   Drivers   written   to   this
          specification.  OS2DASD.SYS  provides support for Read/Write direct
          access devices.

          OS2SCSI.SYS (SCSI.SYS replacement) This  is an  OS/2 device  Driver
          which is compatible existing with "Device Class Drivers" written to
          IBM's SCSI.SYS specification.  OS2SCSI.SYS  will  communicate  with
          Adapter Device Drivers  written  to this specification and provides
          support for CD-ROM, TAPE, and other non-DASD devices.

          Physical Address A  32-Bit byte  address giving  the actual storage
          address in physical storage for a data item.

          Programmed I/O (PIO) The  transfer of data  between  an adapter and
          host CPU using IN/OUT instructions.

          Notification Callout When an Adapter Device Driver receives  an I/O
          request block, the IORB may specify the address of  a routine to be
          called  on  completion  of  the  request.  Calling this routine  is
          referred to as a Notification Callout.





          
                                                     Appendix H: Glossary  91




          
          Notification Routine The  routine indicated in an I/O request block
          to be  called on completion  of that I/O request. See "Notification
          Callout".

          Relative Block Address (RBA) Most  direct  access  devices  have an
          inherent  unit  of allocation (usually  a sector).  This allocation
          unit is referred  to  as  a BLOCK and  is  considered  the smallest
          addressable  quantity  on  the device.  Relative  Block  Addressing
          treats a device being  composed  of  consecutively  numbered blocks
          starting at 0. RBA numbering is done without regard to any physical
          characteristics  (Cylinder,  Head  Sector)  organization  that  the
          device may exhibit.

          Scatter/Gather List A  array   of  Scatter/Gather  elements.   Each
          element consists  of a 32-Bit Physical  Address  and  a 32-Bit Byte
          Count field.  This  list is used to describe data buffers which are
          composed of multiple sections of physical memory.

          Sense Information A data  structure  defined by the  Small Computer
          System  Interface  (SCSI)  to  return  diagnostic information  from
          devices conforming to SCSI standards.

          Small System Computer Interface (SCSI) A  device bus  specification
          defined by the American National Standard Institute (ANSI) allowing
          attachment of a wide variety of devices on a shared bus.

          Strategy (I) OS/2 device drivers (including Adapter Device Drivers)
          define  an entry  point to receive requests from the  OS/2  kernel.
          Adapter  Device Drivers  receive a small subset  of  OS/2  requests
          through  this  entry  point.  Refer  to  this specification for the
          requests adapter device drivers are required to support.

          Strategy II A new file system to device driver interface introduced
          in OS/2 2.0 which allows the passing of multiple requests from OS/2
          file systems to device drivers. OS2DASD.SYS manages the Stratery II
          interfaces  on  behalf  of  Adapter  Device  Drivers.  For  further
          information  refer to  "OS/2  Programming  Tools and Information  -
          Version 2.0", Extended Device Driver Interface.

          Subsystem Control Block (SCB) Architecture Subsystems       Control
          Blocks are  a  CPU  to  adapter  protocol which IBM has  defined to
          communicate with some of it adapters.  Support  of SCB architecture
          is not required by this specification.

          Task Time Task Time refers to an OS/2 device driver being called as
          the  result  of  an  application  request,  rather than due  to  an
          hardware interrupt.








          
                                                     Appendix H: Glossary  92




          
          Unit A  unit  in this specification refers to an addressable entity
          managed  by  an  Adapter Device Driver. The unit may actually  be a
          specific physical device or may  be a composite of physical devices
          managed by an Adapter Device Driver to appear as a single device.

          Unit Handle A 16-bit value returned by an Adapter Device Driver for
          each unit specified in its DEVICE TABLE.  I/O Request Blocks passed
          to the Adapter Device Driver will contain this unit handle.















































          
                                                     Appendix H: Glossary  93




          
          Error 15 at line 15 on page    64 file OS2INTER.SCR line 2024 
     LDS  SI, ADD_Name            ; DS:SI = Ptr ADD to ASCIIZ name
                                      ^

Error 15 at line 17 on page    64 file OS2INTER.SCR line 2024 
     MOV  AX,SEGMENT ADD_Function ; AX:BX = Ptr to ADD's Direct Call
                                      ^

Error 15 at line 27 on page    65 file OS2INTER.SCR line 2058 
         AX:BX = global ptr to a table of registered
           ^












































          
                                                     Appendix H: Glossary  93
